(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    definition(module.exports, localRequire(name), module);
    var exports = cache[name] = module.exports;
    return exports;
  };

  var require = function(name) {
    var path = expand(name, '.');

    if (has(cache, path)) return cache[path];
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex];
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.brunch = true;
})();

window.require.register("application", Function('exports, require, module', "var Application, Chaplin, Layout, mediator, routes, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nLayout = require('views/layout');\n\nmediator = require('mediator');\n\nroutes = require('routes');\n\nmodule.exports = Application = (function(_super) {\n  __extends(Application, _super);\n\n  function Application() {\n    _ref = Application.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Application.prototype.title = 'shiny wight';\n\n  Application.prototype.initialize = function() {\n    Application.__super__.initialize.apply(this, arguments);\n    this.initDispatcher({\n      controllerSuffix: '-controller'\n    });\n    this.initLayout();\n    this.initMediator();\n    this.initControllers();\n    this.initGameSpecificStuff();\n    this.initRouter(routes);\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  Application.prototype.initLayout = function() {\n    return this.layout = new Layout({\n      title: this.title\n    });\n  };\n\n  Application.prototype.initControllers = function() {};\n\n  Application.prototype.initMediator = function() {\n    var _this = this;\n\n    mediator.map = null;\n    mediator.physicsManager = null;\n    mediator.soundManager = null;\n    mediator.PlayWithSounds = false;\n    mediator.factory = {};\n    mediator.entities = [];\n    mediator.levels = {};\n    mediator.activeLevel = \"\";\n    mediator.std = null;\n    mediator.getActiveLevel = function() {\n      return mediator.levels[mediator.activeLevel];\n    };\n    return mediator.seal();\n  };\n\n  Application.prototype.initGameSpecificStuff = function() {\n    (function() {\n      var lastTime, vendors, x;\n\n      lastTime = 0;\n      vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\n      x = 0;\n      while (x < vendors.length && !window.requestAnimationFrame) {\n        window.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n        window.cancelAnimationFrame = window[vendors[x] + \"CancelAnimationFrame\"] || window[vendors[x] + \"CancelRequestAnimationFrame\"];\n        ++x;\n      }\n      if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime, id, timeToCall;\n\n          currTime = new Date().getTime();\n          timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          id = window.setTimeout(function() {\n            return callback(currTime + timeToCall);\n          }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n      if (!window.cancelAnimationFrame) {\n        return window.cancelAnimationFrame = function(id) {\n          return clearTimeout(id);\n        };\n      }\n    })();\n    window.debug = document.location.hash.match(/debug/) && (typeof console !== \"undefined\" && console !== null);\n    return Object.getPrototypeOf(document.createElement('canvas').getContext('2d')).drawImageTiled = function(img, sx, sy, sw, sh, dx, dy, dw, dh, tileSizeX, tileSizeY) {\n      return this.drawImage(img, sx * tileSizeX, sy * tileSizeY, sw * tileSizeX, sh * tileSizeY, dx * tileSizeX, dy * tileSizeY, dw * tileSizeX, dh * tileSizeY);\n    };\n  };\n\n  return Application;\n\n})(Chaplin.Application);\n\n//@ sourceURL=application.coffee"));
window.require.register("controllers/base/controller", Function('exports, require, module', "var Chaplin, Controller, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Controller = (function(_super) {\n  __extends(Controller, _super);\n\n  function Controller() {\n    _ref = Controller.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Controller;\n\n})(Chaplin.Controller);\n\n//@ sourceURL=controllers/base/controller.coffee"));
window.require.register("controllers/home-controller", Function('exports, require, module', "var Controller, HomeController, HomePageView, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nController = require('controllers/base/controller');\n\nHomePageView = require('views/home-page-view');\n\nmodule.exports = HomeController = (function(_super) {\n  __extends(HomeController, _super);\n\n  function HomeController() {\n    _ref = HomeController.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  HomeController.prototype.index = function() {\n    return this.view = new HomePageView({\n      gMap: this.gMap\n    });\n  };\n\n  return HomeController;\n\n})(Controller);\n\n//@ sourceURL=controllers/home-controller.coffee"));
window.require.register("initialize", Function('exports, require, module', "var Application;\n\nApplication = require('application');\n\n$(function() {\n  var app;\n\n  app = new Application();\n  return app.initialize();\n});\n\n//@ sourceURL=initialize.coffee"));
window.require.register("lib/support", Function('exports, require, module', "var Chaplin, support, utils;\n\nChaplin = require('chaplin');\n\nutils = require('lib/utils');\n\nsupport = utils.beget(Chaplin.support);\n\nmodule.exports = support;\n\n//@ sourceURL=lib/support.coffee"));
window.require.register("lib/utils", Function('exports, require, module', "var Chaplin, utils;\n\nChaplin = require('chaplin');\n\nutils = Chaplin.utils.beget(Chaplin.utils);\n\nmodule.exports = utils;\n\n//@ sourceURL=lib/utils.coffee"));
window.require.register("lib/view-helper", Function('exports, require, module', "var mediator,\n  __slice = [].slice;\n\nmediator = require('mediator');\n\nHandlebars.registerHelper('with', function(context, options) {\n  if (!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(context);\n  }\n});\n\nHandlebars.registerHelper('without', function(context, options) {\n  var inverse;\n\n  inverse = options.inverse;\n  options.inverse = options.fn;\n  options.fn = inverse;\n  return Handlebars.helpers[\"with\"].call(this, context, options);\n});\n\nHandlebars.registerHelper('url', function() {\n  var params, routeName, url;\n\n  routeName = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  url = null;\n  mediator.publish('!router:reverse', routeName, params, function(result) {\n    return url = result;\n  });\n  return \"/\" + url;\n});\n\n//@ sourceURL=lib/view-helper.coffee"));
window.require.register("mediator", Function('exports, require, module', "module.exports = require('chaplin').mediator;\n\n//@ sourceURL=mediator.coffee"));
window.require.register("models/DeadEntity", Function('exports, require, module', "var DeadEntity, VisibleEntity, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVisibleEntity = require('models/VisibleEntity');\n\nmodule[\"extends\"] = DeadEntity = (function(_super) {\n  __extends(DeadEntity, _super);\n\n  function DeadEntity() {\n    _ref = DeadEntity.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return DeadEntity;\n\n})(VisibleEntity);\n\n//@ sourceURL=models/DeadEntity.coffee"));
window.require.register("models/Entity", Function('exports, require, module', "var Entity, Model, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\n/*\nBase class for all entities\n\n@example How to subclass Entity\n  module.exports = class VisibleEntity extends Entity\n    onAction: (object): ->\n      # do something\n*/\n\n\nmodule.exports = Entity = (function(_super) {\n  __extends(Entity, _super);\n\n  /*\n  @property [Object] The entity's position in pixels\n  @option position [Integer] x y coordinate\n  */\n\n\n  Entity.prototype.position = {\n    x: 0,\n    y: 0\n  };\n\n  /*\n  @property [Object] The entity's size\n  */\n\n\n  Entity.prototype.size = {\n    x: 0,\n    y: 0\n  };\n\n  /*\n  @property [Integer]\n  What sprite to draw\n  */\n\n\n  Entity.prototype.animationStep = 0;\n\n  /*\n  @property [Integer]\n  Entity' velocity\n  Standart velocity = 10\n  */\n\n\n  Entity.prototype.VELOCITY = 400;\n\n  /*\n  @property [Integer]\n  In what direction the entity looks\n  \n      0:up\n      1:right\n      2:down\n      3:left\n  */\n\n\n  Entity.prototype.viewDirection = 0;\n\n  function Entity(x, y, width, height, settings) {\n    this.update = __bind(this.update, this);\n    this.onPositionChange = __bind(this.onPositionChange, this);\n    this.onAction = __bind(this.onAction, this);    Entity.__super__.constructor.apply(this, arguments);\n    this.position = {\n      x: x,\n      y: y\n    };\n    this.size = {\n      x: width,\n      y: height\n    };\n  }\n\n  /*\n  @private\n  Initializes the new Entity.\n  Will try to get the map from the mediator.\n  @note Make sure to call `TILEDMap.load(path)` before instantiating any Entities.\n  */\n\n\n  Entity.prototype.initialize = function() {\n    return this.map = mediator.levels[mediator.activeLevel].gMap;\n  };\n\n  /*\n  Is called if the Player stands in front of this Entity and want's to interact with it.\n  @param [Object] player\n    The Player.\n  */\n\n\n  Entity.prototype.onAction = function(player) {};\n\n  /*\n  Is called when the Entity moved\n  @note removed publish event 'anyEntityhere:moved' for much(!) better performance\n  */\n\n\n  Entity.prototype.onPositionChange = function() {};\n\n  /*\n  Is called each tick/frame.\n  */\n\n\n  Entity.prototype.update = function() {};\n\n  return Entity;\n\n})(Model);\n\n//@ sourceURL=models/Entity.coffee"));
window.require.register("models/EntitySpawnManager", Function('exports, require, module', "var EntitySpawnManager, Model, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require(\"mediator\");\n\nmodule.exports = EntitySpawnManager = (function(_super) {\n  __extends(EntitySpawnManager, _super);\n\n  function EntitySpawnManager() {\n    this.initialSpawn = __bind(this.initialSpawn, this);    _ref = EntitySpawnManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  EntitySpawnManager.prototype.initialSpawn = function() {\n    var currMapData, height, layer, map, obj, object, width, x, y, _i, _len, _ref1, _results;\n\n    map = mediator.levels[mediator.activeLevel].gMap;\n    currMapData = map.get('currMapData');\n    _ref1 = currMapData.layers;\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      layer = _ref1[_i];\n      if (layer.type === 'tilelayer') {\n        continue;\n      }\n      if (layer.name !== 'spawnpoints') {\n        continue;\n      }\n      _results.push((function() {\n        var _j, _len1, _ref2, _results1;\n\n        _ref2 = layer.objects;\n        _results1 = [];\n        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n          object = _ref2[_j];\n          if (object.type === '') {\n            continue;\n          }\n          x = Math.floor(object.x);\n          y = Math.floor(object.y);\n          width = Math.floor(object.width);\n          height = Math.floor(object.height);\n          obj = new mediator.factory[object.type](x, y, width, height, mediator.getActiveLevel().entities[object.type]);\n          obj.position.x = Math.floor(object.x);\n          obj.position.y = Math.floor(object.y);\n          obj.size.x = Math.floor(object.width);\n          obj.size.y = Math.floor(object.height);\n          obj.load();\n          mediator.entities.push(obj);\n          if (object.type === \"Player\") {\n            _results1.push(mediator.player = obj);\n          } else {\n            _results1.push(void 0);\n          }\n        }\n        return _results1;\n      })());\n    }\n    return _results;\n  };\n\n  return EntitySpawnManager;\n\n})(Model);\n\n//@ sourceURL=models/EntitySpawnManager.coffee"));
window.require.register("models/InputManager", Function('exports, require, module', "var InputManager, Model, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmodule.exports = InputManager = (function(_super) {\n  __extends(InputManager, _super);\n\n  function InputManager() {\n    this.bind = __bind(this.bind, this);\n    this.onKeyUpEvent = __bind(this.onKeyUpEvent, this);\n    this.onKeyDownEvent = __bind(this.onKeyDownEvent, this);\n    this.initialize = __bind(this.initialize, this);    _ref = InputManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  InputManager.prototype.defaults = {\n    bindings: {},\n    actions: {},\n    presses: {},\n    locks: {},\n    delayedKeyup: [],\n    keyCodes: {\n      'a': 65,\n      'w': 87,\n      'd': 68,\n      's': 83,\n      'enter': 13,\n      'escape': 27,\n      'space': 32\n    }\n  };\n\n  InputManager.prototype.initialize = function() {\n    var keyCodes;\n\n    keyCodes = this.get('keyCodes');\n    this.bind(keyCodes['w'], 'move-up');\n    this.bind(keyCodes['a'], 'move-left');\n    this.bind(keyCodes['s'], 'move-down');\n    this.bind(keyCodes['d'], 'move-right');\n    this.bind(keyCodes['enter'], 'interact');\n    this.bind(keyCodes['space'], 'interact');\n    this.bind(keyCodes['escape'], 'cancel');\n    window.addEventListener('keydown', this.onKeyDownEvent);\n    window.addEventListener('keyup', this.onKeyUpEvent);\n    return this.otherKeyPressed = false;\n  };\n\n  /*\n  Set the corresponding action in the actions array to true\n  \n      Pressing `w` will set `move-up` to true on an qwerty keyboard\n  @params [Event] event Event Object\n  */\n\n\n  InputManager.prototype.onKeyDownEvent = function(event) {\n    var action, actions, bindings, code;\n\n    code = event['keyCode'];\n    if (this.otherKeyPressed) {\n      this.onKeyUpEvent(this.otherKeyPressed);\n    }\n    bindings = this.get('bindings');\n    actions = this.get('actions');\n    action = bindings[code];\n    if (action) {\n      actions[action] = true;\n    }\n    this.set({\n      'actions': actions\n    });\n    return this.otherKeyPressed = event;\n  };\n\n  /*\n  Set the corresponding action in the actions array to false\n  \n      Releasing `w` will set `move-up` to false on an qwerty keyboard\n  @params [Event] event Event Object\n  */\n\n\n  InputManager.prototype.onKeyUpEvent = function(event) {\n    var action, actions, bindings, code;\n\n    bindings = this.get('bindings');\n    actions = this.get('actions');\n    code = event['keyCode'];\n    action = bindings[code];\n    if (action) {\n      actions[action] = false;\n    }\n    return this.set({\n      'actions': actions\n    });\n  };\n\n  /*\n  Bind a key code to an action.\n  @example How to bind `w` to the `move-up` action\n    @bind 87, 'move-up'\n  */\n\n\n  InputManager.prototype.bind = function(key, action) {\n    var bindings;\n\n    bindings = this.get('bindings');\n    return bindings[key] = action;\n  };\n\n  return InputManager;\n\n})(Model);\n\n//@ sourceURL=models/InputManager.coffee"));
window.require.register("models/Level", Function('exports, require, module', "var Level, Model, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nmodule.exports = Level = (function(_super) {\n  var loadCompleted;\n\n  __extends(Level, _super);\n\n  Level.prototype.manifest = null;\n\n  Level.prototype.soundList = {};\n\n  Level.prototype.backgroundSounds = {};\n\n  Level.prototype.soundLoadCount = 0;\n\n  Level.prototype.soundCount = 0;\n\n  Level.prototype.physicsMap = [];\n\n  Level.prototype.entities = {};\n\n  Level.prototype.bodyCount = 0;\n\n  Level.prototype.gMap = null;\n\n  loadCompleted = false;\n\n  function Level(manifestUri, callback) {\n    this.setup = __bind(this.setup, this);\n    var _this = this;\n\n    mediator.std.xhrGet(manifestUri, function(data) {\n      var file, _i, _len, _ref, _results;\n\n      _this.manifest = JSON.parse(data.target.responseText);\n      _this.sounds = _this.manifest.sounds;\n      _this.map = _this.manifest.map;\n      _this.bodyCount = _this.manifest.entities.files.length;\n      _ref = _this.manifest.entities.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        _results.push(mediator.std.xhrGet(_this.manifest.entities.prefix + '/' + file, function(data) {\n          var ent;\n\n          ent = JSON.parse(data.target.responseText);\n          _this.entities[ent.name] = ent;\n          _this.bodyCount--;\n          if (_this.bodyCount <= 0) {\n            _this.loadCompleted = true;\n            if (callback) {\n              return callback();\n            }\n          }\n        }));\n      }\n      return _results;\n    });\n  }\n\n  Level.prototype.setup = function() {\n    if (this.loadCompleted) {\n\n    } else {\n      return console.error(\"Don't call Level.setup() unless the manifest finished loading\");\n    }\n  };\n\n  return Level;\n\n})(Model);\n\n//@ sourceURL=models/Level.coffee"));
window.require.register("models/MapChanger", Function('exports, require, module', "var Entity, MapChanger, mediator, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nEntity = require('models/Entity');\n\nmediator = require('mediator');\n\nmodule.exports = MapChanger = (function(_super) {\n  __extends(MapChanger, _super);\n\n  function MapChanger() {\n    _ref = MapChanger.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  mediator.factory['Player'] = MapChanger;\n\n  MapChanger.prototype.levelToChangeTo = \"\";\n\n  return MapChanger;\n\n})(Entity);\n\n//@ sourceURL=models/MapChanger.coffee"));
window.require.register("models/PhysicsManager", Function('exports, require, module', "var Body, BodyDef, CircleShape, DebugDraw, Fixture, FixtureDef, MassData, Model, PhysicsManager, PolygonShape, RevoluteJointDef, Vec2, World, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nVec2 = Box2D.Common.Math.b2Vec2;\n\nBodyDef = Box2D.Dynamics.b2BodyDef;\n\nBody = Box2D.Dynamics.b2Body;\n\nFixtureDef = Box2D.Dynamics.b2FixtureDef;\n\nFixture = Box2D.Dynamics.b2Fixture;\n\nWorld = Box2D.Dynamics.b2World;\n\nMassData = Box2D.Collision.Shapes.b2MassData;\n\nPolygonShape = Box2D.Collision.Shapes.b2PolygonShape;\n\nCircleShape = Box2D.Collision.Shapes.b2CircleShape;\n\nDebugDraw = Box2D.Dynamics.b2DebugDraw;\n\nRevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;\n\n/*\nContains a map with all physics bodies.\nCan be used by Entities to decide whether they can move to a specific tile.\n@note The PhysicsManager expects only only one physics layer to be present\n*/\n\n\nmodule.exports = PhysicsManager = (function(_super) {\n  __extends(PhysicsManager, _super);\n\n  function PhysicsManager() {\n    this.removeBody = __bind(this.removeBody, this);\n    this.addBody = __bind(this.addBody, this);\n    this.registerBody = __bind(this.registerBody, this);\n    this.addContactListener = __bind(this.addContactListener, this);\n    this.update = __bind(this.update, this);\n    this.createLevelBorder = __bind(this.createLevelBorder, this);\n    this.createStaticBodyWithPolygon = __bind(this.createStaticBodyWithPolygon, this);\n    this.createStaticBodyWithBox = __bind(this.createStaticBodyWithBox, this);\n    this.addBackgroundRigidBodies = __bind(this.addBackgroundRigidBodies, this);\n    this.setup = __bind(this.setup, this);    _ref = PhysicsManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  PhysicsManager.prototype.world = null;\n\n  PhysicsManager.prototype.physicsLoopHZ = 1 / 25;\n\n  PhysicsManager.prototype.Vec2 = Box2D.Common.Math.b2Vec2;\n\n  PhysicsManager.prototype.BodyDef = Box2D.Dynamics.b2BodyDef;\n\n  PhysicsManager.prototype.Body = Box2D.Dynamics.b2Body;\n\n  PhysicsManager.prototype.FixtureDef = Box2D.Dynamics.b2FixtureDef;\n\n  PhysicsManager.prototype.Fixture = Box2D.Dynamics.b2Fixture;\n\n  PhysicsManager.prototype.World = Box2D.Dynamics.b2World;\n\n  PhysicsManager.prototype.MassData = Box2D.Collision.Shapes.b2MassData;\n\n  PhysicsManager.prototype.PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;\n\n  PhysicsManager.prototype.CircleShape = Box2D.Collision.Shapes.b2CircleShape;\n\n  PhysicsManager.prototype.DebugDraw = Box2D.Dynamics.b2DebugDraw;\n\n  PhysicsManager.prototype.RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;\n\n  /*\n  @private\n  Initializes an instance\n  */\n\n\n  PhysicsManager.prototype.initialize = function() {\n    PhysicsManager.__super__.initialize.apply(this, arguments);\n    return mediator.physicsManager = this;\n    /*\n    @subscribeEvent 'map:rendered', =>\n      @setup()\n    */\n\n  };\n\n  /*\n  Look for the physics layer inside the map.\n  Fills in a local representation of it.\n  @note The PhysicsManager expects only only one physics layer to be present\n  */\n\n\n  PhysicsManager.prototype.setup = function() {\n    var dCanvas, dCtx, debugDraw, map;\n\n    map = mediator.levels[mediator.activeLevel].gMap;\n    this.world = new World(new Vec2(0, 0), false);\n    debugDraw = new Box2D.Dynamics.b2DebugDraw();\n    dCanvas = document.createElement('canvas');\n    dCtx = dCanvas.getContext('2d');\n    this.createLevelBorder(map);\n    document.getElementById('debug-container').appendChild(dCanvas);\n    dCanvas.width = window.innerWidth / 2 - 100;\n    dCanvas.height = window.innerHeight;\n    debugDraw.SetSprite(dCtx);\n    debugDraw.SetDrawScale(0.5);\n    debugDraw.SetFillAlpha(0.3);\n    debugDraw.SetLineThickness(1);\n    debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit);\n    this.world.SetDebugDraw(debugDraw);\n    return this.addBackgroundRigidBodies(map);\n  };\n\n  PhysicsManager.prototype.addBackgroundRigidBodies = function(map) {\n    var layer, object, physicsTile, pkt, tileID, tileIndex, tileSize, vec2, vec2Array, x, y, _i, _len, _ref1, _results;\n\n    _ref1 = map.currMapData.layers;\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      layer = _ref1[_i];\n      if (layer.name !== 'physics') {\n        continue;\n      }\n      if (layer.type === 'objectgroup') {\n        _results.push((function() {\n          var _j, _len1, _ref2, _results1;\n\n          _ref2 = layer.objects;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            object = _ref2[_j];\n            if (object.polygon) {\n              vec2Array = (function() {\n                var _k, _len2, _ref3, _results2;\n\n                _ref3 = object.polygon;\n                _results2 = [];\n                for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n                  vec2 = _ref3[_k];\n                  _results2.push(new Vec2(vec2.x, vec2.y));\n                }\n                return _results2;\n              })();\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, object.x, object.y));\n            } else {\n              _results1.push(this.createStaticBodyWithBox(object.x, object.y, object.width, object.height));\n            }\n          }\n          return _results1;\n        }).call(this));\n      } else if (layer.type === 'tilelayer') {\n        map = mediator.levels[mediator.activeLevel].gMap;\n        _results.push((function() {\n          var _j, _len1, _ref2, _results1;\n\n          _ref2 = layer.data;\n          _results1 = [];\n          for (tileIndex = _j = 0, _len1 = _ref2.length; _j < _len1; tileIndex = ++_j) {\n            tileID = _ref2[tileIndex];\n            if (tileID === 0) {\n              continue;\n            }\n            x = (tileIndex % map.numXTiles) * map.tileSize.x;\n            y = Math.floor(tileIndex / map.numXTiles) * map.tileSize.y;\n            pkt = map.getTilePacket(tileID);\n            physicsTile = pkt.px / map.tileSize.x;\n            tileSize = map.tileSize.x;\n            if (physicsTile === 0) {\n              _results1.push(this.createStaticBodyWithBox(x, y, tileSize, tileSize));\n            } else if (physicsTile === 1) {\n              vec2Array = [new Vec2(0, tileSize), new Vec2(tileSize, 0), new Vec2(tileSize, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 2) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, tileSize), new Vec2(0, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 3) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, 0), new Vec2(tileSize, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 4) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, 0), new Vec2(0, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else {\n              _results1.push(void 0);\n            }\n          }\n          return _results1;\n        }).call(this));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  PhysicsManager.prototype.createStaticBodyWithBox = function(x, y, w, h) {\n    var bgRigidBody, body, fixtureDefinition;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(w / 2, h / 2);\n    bgRigidBody = new BodyDef();\n    bgRigidBody.type = Body.b2_staticBody;\n    bgRigidBody.position.x = x + w / 2;\n    bgRigidBody.position.y = y + h / 2;\n    body = this.registerBody(bgRigidBody);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  PhysicsManager.prototype.createStaticBodyWithPolygon = function(vec2Array, x, y) {\n    var bgRigidBody, body, fixtureDefinition;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsArray(vec2Array, vec2Array.length);\n    bgRigidBody = new BodyDef();\n    bgRigidBody.type = Body.b2_staticBody;\n    bgRigidBody.position.x = x;\n    bgRigidBody.position.y = y;\n    body = this.registerBody(bgRigidBody);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  /*\n  @todo should actually go to TILEDMap.coffee\n  */\n\n\n  PhysicsManager.prototype.createLevelBorder = function(map) {\n    var body, fixtureDefinition, mapBorder;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(0, map.pixelSize.y);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(0, map.pixelSize.y);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = map.pixelSize.x;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(map.pixelSize.x, 0);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(map.pixelSize.x, 0);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = map.pixelSize.y;\n    body = this.registerBody(mapBorder);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  PhysicsManager.prototype.update = function() {\n    var start;\n\n    start = Date.now();\n    this.world.Step(this.physicsLoopHZ, 10, 10);\n    if (debug) {\n      this.world.DrawDebugData();\n    }\n    return Date.now() - start;\n  };\n\n  PhysicsManager.prototype.addContactListener = function(callbacks) {\n    var listener,\n      _this = this;\n\n    listener = new Box2D.Dynamics.b2ContactListener();\n    if (callbacks.PostSolve) {\n      listener.PostSolve = function(contact, impulse) {\n        return callbacks.PostSolve(contact.GetFixtureA().GetBody(), contact.GetFixtureB.GetBody, impulse.normalImpulses[0]);\n      };\n    }\n    return this.world.SetContactListener(listener);\n  };\n\n  PhysicsManager.prototype.registerBody = function(bodyDef) {\n    var body;\n\n    return body = this.world.CreateBody(bodyDef);\n  };\n\n  PhysicsManager.prototype.addBody = function(entityDef) {\n    var body, bodyDef, fixtureDefinition, id;\n\n    bodyDef = new BodyDef();\n    id = entityDef.id;\n    if (entityDef.type === 'static') {\n      bodyDef.type = Body.b2_staticBody;\n    } else {\n      bodyDef.type = Body.b2_dynamicBody;\n    }\n    bodyDef.position.x = entityDef.x;\n    bodyDef.position.y = entityDef.y;\n    if (entityDef.userData) {\n      bodyDef.userData = entityDef.userData;\n    }\n    body = this.registerBody(bodyDef);\n    fixtureDefinition = new FixtureDef();\n    if (id === 'Player') {\n      fixtureDefinition.shape = new CircleShape();\n      fixtureDefinition.shape.SetRadius(entityDef.halfWidth);\n    } else {\n      fixtureDefinition.shape = new PolygonShape();\n      fixtureDefinition.shape.SetAsBox(entityDef.halfWidth, entityDef.halfHeight);\n    }\n    body.CreateFixture(fixtureDefinition);\n    return body;\n  };\n\n  PhysicsManager.prototype.removeBody = function(obj) {\n    return this.world.DestroyBody(obj);\n  };\n\n  return PhysicsManager;\n\n})(Model);\n\n//@ sourceURL=models/PhysicsManager.coffee"));
window.require.register("models/Player", Function('exports, require, module', "var Entity, Player, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nEntity = require('models/Entity');\n\nmediator = require('mediator');\n\n/*\nThe Player\n*/\n\n\nmodule.exports = Player = (function(_super) {\n  __extends(Player, _super);\n\n  mediator.factory['Player'] = Player;\n\n  Player.prototype.animationState = [0, 1, 2, 1];\n\n  function Player(x, y, width, height, settings) {\n    this.render = __bind(this.render, this);\n    this.getSpritePacket = __bind(this.getSpritePacket, this);\n    this.update = __bind(this.update, this);\n    this.onTouch = __bind(this.onTouch, this);\n    this.load = __bind(this.load, this);\n    this.kill = __bind(this.kill, this);\n    var content, prop;\n\n    Player.__super__.constructor.call(this, x, y, width, height, settings);\n    for (prop in settings) {\n      content = settings[prop];\n      this[prop] = content;\n    }\n    this.spriteState.creationTime = Date.now();\n    this.entityDef.x = this.position.x;\n    this.entityDef.y = this.position.y;\n    this.entityDef.userData.ent = this;\n    this.physBody = mediator.physicsManager.addBody(this.entityDef);\n    this.physBody.SetLinearVelocity(new mediator.physicsManager.Vec2(0, 0));\n  }\n\n  Player.prototype.kill = function() {\n    mediator.physicsManager.removeBody(this.physBody);\n    this.physBody = null;\n    return this.killed = true;\n  };\n\n  Player.prototype.load = function() {\n    var img, tileSet;\n\n    tileSet = this.tileSet;\n    img = new Image();\n    img.src = tileSet.image;\n    return this.set({\n      'atlas': img\n    });\n  };\n\n  Player.prototype.onTouch = function(otherBody, point, impulse) {\n    var physOwner;\n\n    if (this.physBody == null) {\n      return false;\n    }\n    if (otherBody.GetUserData() == null) {\n      return false;\n    }\n    physOwner = otherBody.GetUserData().ent;\n    if (physOwner != null ? physOwner.killed : void 0) {\n      return false;\n    } else {\n\n    }\n  };\n\n  Player.prototype.update = function() {\n    if (this.physBody.GetPosition().x != null) {\n      this.position.x = this.physBody.GetPosition().x;\n    }\n    if (this.physBody.GetPosition().y != null) {\n      return this.position.y = this.physBody.GetPosition().y;\n    }\n  };\n\n  Player.prototype.getSpritePacket = function() {\n    var pkt, x, y;\n\n    x = Math.floor((Date.now() - this.spriteState.creationTime) / this.spriteState.animationRate) % this.tileSet.tilesX;\n    y = this.spriteState.viewDirection;\n    if (!this.spriteState.moving) {\n      x = this.spriteState.normal;\n    }\n    return pkt = {\n      x: x * this.tileSet.tilewidth,\n      y: y * this.tileSet.tileheight\n    };\n  };\n\n  Player.prototype.render = function(ctx, cx, cy) {\n    var animationState, dh, dw, dx, dy, img, sh, spritePkt, sw, sx, sy, tileSet;\n\n    tileSet = this.tileSet;\n    animationState = this.animationState;\n    img = this.get('atlas');\n    spritePkt = this.getSpritePacket();\n    sx = spritePkt.x;\n    sy = spritePkt.y;\n    sw = this.tileSet.tilewidth;\n    sh = this.tileSet.tileheight;\n    dx = this.position.x - cx;\n    dy = this.position.y - cy;\n    dw = this.size.x;\n    dh = this.size.y;\n    dx = dx - this.tileSet.offset.x;\n    dy = dy - this.tileSet.offset.y;\n    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\n  };\n\n  Player.prototype.onPositionChange = function() {\n    return mediator.soundManager.updateBackgroundSounds(this.position);\n  };\n\n  return Player;\n\n})(Entity);\n\n//@ sourceURL=models/Player.coffee"));
window.require.register("models/SoundManager", Function('exports, require, module', "var Model, SoundManager, SoundObj, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nSoundObj = require('models/SoundObj');\n\nmediator = require('mediator');\n\nmodule.exports = SoundManager = (function(_super) {\n  __extends(SoundManager, _super);\n\n  function SoundManager() {\n    this.startAll = __bind(this.startAll, this);\n    this.fade = __bind(this.fade, this);\n    this.updateBackgroundSounds = __bind(this.updateBackgroundSounds, this);\n    this.startBackgroundSounds = __bind(this.startBackgroundSounds, this);\n    this.stopAll = __bind(this.stopAll, this);\n    this.stop = __bind(this.stop, this);\n    this.playSound = __bind(this.playSound, this);\n    this.bufferSounds = __bind(this.bufferSounds, this);\n    this.loadSounds = __bind(this.loadSounds, this);\n    this.initializeSoundMap = __bind(this.initializeSoundMap, this);\n    this.load = __bind(this.load, this);\n    this.initialize = __bind(this.initialize, this);    _ref = SoundManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  SoundManager.prototype.audioContext = null;\n\n  SoundManager.prototype.PATH = 'sounds/';\n\n  SoundManager.prototype.FADE_TIME_INTERVAL = 1;\n\n  /*\n  Initialize Soundmanager.\n  Create a new audio context and bind soundManager to mediator\n  */\n\n\n  SoundManager.prototype.initialize = function() {\n    SoundManager.__super__.initialize.apply(this, arguments);\n    mediator.soundManager = this;\n    this.audioContext = new webkitAudioContext();\n    return this.subscribeEvent('stopCurrentSounds', this.stopAll);\n  };\n\n  /*\n  @param [String]\n  Start loading of level. The level to load is determined by the String LEVEL\n  @note later change listener based to observer based event system\n  */\n\n\n  SoundManager.prototype.load = function(LEVEL) {\n    var mapSounds;\n\n    this.initializeSoundMap(LEVEL, mediator.levels[LEVEL].gMap);\n    mapSounds = mediator.levels[LEVEL].sounds;\n    mediator.levels[LEVEL].soundCount = mapSounds.sounds.length + mapSounds.backgroundSounds.length;\n    mediator.levels[LEVEL].soundLoadCount = 0;\n    return this.loadSounds(LEVEL, mapSounds);\n  };\n\n  /*\n  @param [String]\n  @param [map]\n  Reads levelX.json file and to all sounds of the level\n  */\n\n\n  SoundManager.prototype.initializeSoundMap = function(LEVEL, map) {\n    var currMapData, layer, tileID, tileIndex, x, y, _i, _j, _len, _ref1, _ref2, _results;\n\n    currMapData = map.get('currMapData');\n    mediator.levels[LEVEL].soundMap = [];\n    for (x = _i = 0, _ref1 = map.numXTiles - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = 0 <= _ref1 ? ++_i : --_i) {\n      mediator.levels[LEVEL].soundMap[x] = (function() {\n        var _j, _ref2, _results;\n\n        _results = [];\n        for (y = _j = 0, _ref2 = map.numYTiles - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; y = 0 <= _ref2 ? ++_j : --_j) {\n          _results.push([]);\n        }\n        return _results;\n      })();\n    }\n    _ref2 = currMapData.layers;\n    _results = [];\n    for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n      layer = _ref2[_j];\n      if (layer.name !== 'sound') {\n        continue;\n      }\n      _results.push((function() {\n        var _k, _len1, _ref3, _results1;\n\n        _ref3 = layer.data;\n        _results1 = [];\n        for (tileIndex = _k = 0, _len1 = _ref3.length; _k < _len1; tileIndex = ++_k) {\n          tileID = _ref3[tileIndex];\n          if (tileID === 0) {\n            continue;\n          }\n          x = tileIndex % map.numXTiles;\n          y = Math.floor(tileIndex / map.numXTiles);\n          _results1.push(mediator.levels[LEVEL].soundMap[x][y].push(layer.properties));\n        }\n        return _results1;\n      })());\n    }\n    return _results;\n  };\n\n  /*\n  @param [String]\n  @param [Array of String]\n  Load all sounds in soundMap\n  */\n\n\n  SoundManager.prototype.loadSounds = function(LEVEL, mapSounds) {\n    var sound, _i, _j, _len, _len1, _ref1, _ref2, _results;\n\n    _ref1 = mapSounds.sounds;\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      sound = _ref1[_i];\n      mediator.levels[LEVEL].soundList[sound] = new SoundObj;\n      mediator.std.xhrGet(this.PATH + sound + '.mp3', this.bufferSounds, 'arraybuffer', sound, mediator.levels[LEVEL].soundList, LEVEL);\n    }\n    _ref2 = mapSounds.backgroundSounds;\n    _results = [];\n    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n      sound = _ref2[_j];\n      mediator.levels[LEVEL].backgroundSounds[sound] = new SoundObj;\n      _results.push(mediator.std.xhrGet(this.PATH + sound + '.mp3', this.bufferSounds, 'arraybuffer', sound, mediator.levels[LEVEL].backgroundSounds, LEVEL));\n    }\n    return _results;\n  };\n\n  /*\n  @param [xhrGethttp-request]\n  Buffer the sound we just got from xhrGet request and put it into the corresponding SourceNode in the audio context\n  @note later trigger the observer event for 'all sounds loaded'\n  */\n\n\n  SoundManager.prototype.bufferSounds = function(event) {\n    var LEVEL, buffer, list, request, sound;\n\n    request = event.target;\n    sound = request.additionalAttributes[0];\n    list = request.additionalAttributes[1];\n    LEVEL = request.additionalAttributes[2];\n    buffer = this.audioContext.createBuffer(request.response, false);\n    list[sound].buffer = buffer;\n    mediator.levels[LEVEL].soundLoadCount++;\n    console.log(sound + '.mp3 loaded');\n    if (mediator.levels[LEVEL].soundLoadCount === mediator.levels[LEVEL].soundCount) {\n      console.log('all sounds loaded');\n      return this.publishEvent('soundsLoaded');\n    }\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  @param [Double]\n  @param [Bool]\n  Play sound of list with volume and loop\n  */\n\n\n  SoundManager.prototype.playSound = function(sound, list, volume, loops) {\n    var sourceNode;\n\n    sourceNode = this.audioContext.createBufferSource();\n    sourceNode.buffer = list[sound].buffer;\n    sourceNode.loop = loops;\n    sourceNode.gain.value = volume;\n    sourceNode.connect(this.audioContext.destination);\n    list[sound].sourceNode = sourceNode;\n    return sourceNode.start(0);\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  Stop sound in list\n  */\n\n\n  SoundManager.prototype.stop = function(sound, list) {\n    var _this = this;\n\n    setTimeout(function() {\n      return _this.fade(sound, list, 0);\n    }, this.FADE_TIME_INTERVAL);\n    list[sound].sourceNode.stop(0);\n    list[sound].isPlaying = false;\n    return console.log(sound + '.mp3 stopped');\n  };\n\n  /*\n  Stop all sounds in active level\n  */\n\n\n  SoundManager.prototype.stopAll = function() {\n    var e, name, sound, _ref1, _ref2, _results;\n\n    try {\n      _ref1 = mediator.levels[mediator.activeLevel].soundList;\n      for (name in _ref1) {\n        sound = _ref1[name];\n        this.stop(name, mediator.levels[mediator.activeLevel].soundList);\n      }\n      _ref2 = mediator.levels[mediator.activeLevel].backgroundSounds;\n      _results = [];\n      for (name in _ref2) {\n        sound = _ref2[name];\n        _results.push(this.stop(name, mediator.levels[mediator.activeLevel].backgroundSounds));\n      }\n      return _results;\n    } catch (_error) {\n      e = _error;\n      return console.log(e.toString());\n    }\n  };\n\n  /*\n  Start all background sounds in backgroundSound list of active level with gain = 0, i.e. muted\n  */\n\n\n  SoundManager.prototype.startBackgroundSounds = function() {\n    var name, sound, _ref1, _results;\n\n    _ref1 = mediator.levels[mediator.activeLevel].backgroundSounds;\n    _results = [];\n    for (name in _ref1) {\n      sound = _ref1[name];\n      this.playSound(name, mediator.levels[mediator.activeLevel].backgroundSounds, 0, true);\n      _results.push(sound.isPlaying = true);\n    }\n    return _results;\n  };\n\n  /*\n  @param [Object]\n  Look for backgroundSounds to play on the player position on the soundMap and update their gain\n  @todo maybe look for an optimization here\n  */\n\n\n  SoundManager.prototype.updateBackgroundSounds = function(PlayerPosition) {\n    var name, sound, _i, _len, _ref1, _ref2, _results;\n\n    this.backgroundSoundsToPlay = [];\n    _ref1 = mediator.levels[mediator.activeLevel].soundMap[Math.floor(PlayerPosition.x / 32)][Math.floor(PlayerPosition.y / 32)];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      sound = _ref1[_i];\n      this.fade(sound.type, mediator.levels[mediator.activeLevel].backgroundSounds, sound.intensity / 100);\n      this.backgroundSoundsToPlay.push(sound.type);\n    }\n    _ref2 = mediator.levels[mediator.activeLevel].backgroundSounds;\n    _results = [];\n    for (name in _ref2) {\n      sound = _ref2[name];\n      if (this.backgroundSoundsToPlay.indexOf(name) === -1) {\n        _results.push(this.fade(name, mediator.levels[mediator.activeLevel].backgroundSounds, 0));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  @param [Double]\n  Fade sound in list to gain\n  */\n\n\n  SoundManager.prototype.fade = function(sound, list, volume) {\n    return list[sound].sourceNode.gain.setTargetAtTime(volume, this.audioContext.currentTime, this.FADE_TIME_INTERVAL);\n  };\n\n  SoundManager.prototype.startAll = function() {\n    this.playSound(mediator.activeLevel + 'theme', mediator.levels[mediator.activeLevel].soundList, 1, true);\n    this.startBackgroundSounds();\n    return this.updateBackgroundSounds(mediator.player.position);\n  };\n\n  return SoundManager;\n\n})(Model);\n\n//@ sourceURL=models/SoundManager.coffee"));
window.require.register("models/SoundObj", Function('exports, require, module', "var Model, SoundObj, mediator, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nmodule.exports = SoundObj = (function(_super) {\n  __extends(SoundObj, _super);\n\n  function SoundObj() {\n    _ref = SoundObj.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  SoundObj.prototype.sourceNode = null;\n\n  SoundObj.prototype.gainNode = null;\n\n  SoundObj.prototype.buffer = null;\n\n  SoundObj.prototype.isPlaying = false;\n\n  return SoundObj;\n\n})(Model);\n\n//@ sourceURL=models/SoundObj.coffee"));
window.require.register("models/Std", Function('exports, require, module', "var Model, Std, mediator, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __slice = [].slice;\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nmodule.exports = Std = (function(_super) {\n  __extends(Std, _super);\n\n  function Std() {\n    _ref = Std.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Std.prototype.initialize = function() {\n    return mediator.std = this;\n  };\n\n  /*\n  Starts a XMLHttpRequest and calls the given callback when finished loading.\n  @param [String] reqUri URI to the file to be loaded\n  @param [Function] callback Callback function\n  */\n\n\n  Std.prototype.xhrGet = function() {\n    var callback, reqUri, rest, xhr;\n\n    reqUri = arguments[0], callback = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n    xhr = new XMLHttpRequest();\n    if (rest.length !== 0) {\n      xhr.responseType = rest[0];\n    }\n    xhr.additionalAttributes = rest.splice(1);\n    xhr.open('GET', reqUri, true);\n    xhr.onload = callback;\n    return xhr.send();\n  };\n\n  return Std;\n\n})(Model);\n\n//@ sourceURL=models/Std.coffee"));
window.require.register("models/TILEDMap", Function('exports, require, module', "var Model, TILEDMap, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\n/*\nLoads and renders a level.\n@note emits `map:rendered` event when map ist fully rendered\n*/\n\n\nmodule.exports = TILEDMap = (function(_super) {\n  __extends(TILEDMap, _super);\n\n  function TILEDMap() {\n    this.render = __bind(this.render, this);\n    this.getTilePacket = __bind(this.getTilePacket, this);\n    this.createTileSet = __bind(this.createTileSet, this);\n    this.parseMapJSON = __bind(this.parseMapJSON, this);\n    this.load = __bind(this.load, this);    _ref = TILEDMap.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  TILEDMap.prototype.defaults = {\n    currMapData: null,\n    tileset: [],\n    numXTiles: 100,\n    numYTiles: 100,\n    tileSize: {\n      x: 64,\n      y: 64\n    },\n    pixelSize: {\n      x: 64,\n      y: 64\n    },\n    fullyLoaded: false,\n    canvas: null,\n    ctx: null\n  };\n\n  /*\n  @private\n  Initializes an instance.\n  */\n\n\n  TILEDMap.prototype.initialize = function(options) {\n    var canvas, ctx;\n\n    TILEDMap.__super__.initialize.apply(this, arguments);\n    this.callWhenRendered = options.callWhenRendered;\n    this.imgLoadCount = 0;\n    canvas = document.createElement('canvas');\n    ctx = canvas.getContext('2d');\n    this.set({\n      'canvas': canvas\n    });\n    return this.set({\n      'ctx': ctx\n    });\n  };\n\n  /*\n  Loads the map, parses it and renders it\n  @param [String] map URI that points to the json output of TILED map editor\n  */\n\n\n  TILEDMap.prototype.load = function(level) {\n    var lvl,\n      _this = this;\n\n    lvl = mediator.levels[level];\n    return mediator.std.xhrGet(lvl.map.prefix + '/' + lvl.map.file, function(data) {\n      return _this.parseMapJSON(data.target.responseText);\n    });\n  };\n\n  /*\n  @private\n  Parses TILED map editor json data\n  @param [JSON] mapJSON the TILED map editor json data\n  */\n\n\n  TILEDMap.prototype.parseMapJSON = function(mapJSON) {\n    var tileset, tilesets;\n\n    this.currMapData = JSON.parse(mapJSON);\n    this.numXTiles = this.currMapData.width;\n    this.numYTiles = this.currMapData.height;\n    this.tileSize = {\n      x: this.currMapData.tileheight,\n      y: this.currMapData.tilewidth\n    };\n    this.pixelSize = {\n      x: this.numXTiles * this.tileSize.x,\n      y: this.numYTiles * this.tileSize.y\n    };\n    this.set({\n      'currMapData': this.currMapData\n    });\n    this.set({\n      'numXTiles': this.numXTiles\n    });\n    this.set({\n      'numYTiles': this.numYTiles\n    });\n    this.set({\n      'tileSize': this.tileSize\n    });\n    this.set({\n      'pixelSize': this.pixelSize\n    });\n    console.log('Start loading atlasses');\n    tilesets = (function() {\n      var _i, _len, _ref1, _results;\n\n      _ref1 = this.currMapData.tilesets;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        tileset = _ref1[_i];\n        _results.push(this.createTileSet(tileset));\n      }\n      return _results;\n    }).call(this);\n    return this.set({\n      'tilesets': tilesets\n    });\n  };\n\n  /*\n  @private\n  Loads an atlas referenced from the map file and returns it\n  @param [Object] tileset a tileset from the map json\n  @return [Object] most important data from that tileset\n  @example The returned Object:\n    ts =\n      firstgid: …    # look at https://github.com/bjorn/tiled/wiki/TMX-Map-Format\n      image: …       # the loaded atlas image\n      imageheight: … # the atlas's height in pixels\n      imagewidth: …  # the atlas's width in pixels\n      name: …        # the atlas's name\n      numXTiles: …   # number of tiles in x direction\n      numYTiles: …   # number of tiles in y direction\n  */\n\n\n  TILEDMap.prototype.createTileSet = function(tileset) {\n    var currMapData, img, tileSize, ts,\n      _this = this;\n\n    currMapData = this.get('currMapData');\n    tileSize = this.get('tileSize');\n    img = new Image();\n    img.onload = function() {\n      _this.imgLoadCount++;\n      if (_this.imgLoadCount === currMapData.tilesets.length) {\n        return _this.render();\n      } else {\n        return console.log(\"\" + (currMapData.tilesets.length - _this.imgLoadCount) + \" to go\");\n      }\n    };\n    img.src = 'atlases/' + tileset.image.replace(/^.*[\\\\\\/]/, '');\n    return ts = {\n      firstgid: tileset.firstgid,\n      image: img,\n      imageheight: tileset.imageheight,\n      imagewidth: tileset.imagewidth,\n      name: tileset.name,\n      numXTiles: Math.floor(tileset.imagewidth / (tileSize.x + tileset.spacing)),\n      numYTiles: Math.floor(tileset.imageheight / (tileSize.y + tileset.spacing)),\n      spacing: tileset.spacing\n    };\n  };\n\n  /*\n  @private\n  Takes a tile ID and returns the tile's atlas and position\n  @param [Integer] tileIndex a tile ID\n  @return [Object] the tile's atlas and position\n  @example the returned Object:\n    pkt =\n      img: … # the atlas where the tile is situated\n      px: …  # x value of the top left corner in pixels\n      py: …  # y value of the top left corner in pixels\n  */\n\n\n  TILEDMap.prototype.getTilePacket = function(tileIndex) {\n    var lTileX, lTileY, localIdx, pkt, tile, tileSize, tilesets, _i;\n\n    pkt = {\n      img: null,\n      px: 0,\n      py: 0\n    };\n    tile = null;\n    tilesets = this.get('tilesets');\n    tileSize = this.get('tileSize');\n    for (_i = tilesets.length - 1; _i >= 0; _i += -1) {\n      tile = tilesets[_i];\n      if (tile.firstgid <= tileIndex) {\n        break;\n      }\n    }\n    pkt.img = tile.image;\n    localIdx = tileIndex - tile.firstgid;\n    lTileX = Math.floor(localIdx % tile.numXTiles);\n    lTileY = Math.floor(localIdx / tile.numXTiles);\n    pkt.py = lTileY * (tileSize.y + tile.spacing) + tile.spacing;\n    pkt.px = lTileX * (tileSize.x + tile.spacing) + tile.spacing;\n    return pkt;\n  };\n\n  /*\n  Renders the map into it's own off screen canvas.\n  This means the whol background can be drawn with one single draw\n  call instead of hundreads.\n  */\n\n\n  TILEDMap.prototype.render = function() {\n    var canvas, coords, ctx, currMapData, layer, numXTiles, numYTiles, tID, tPKT, tileIDX, tileSize, _i, _j, _len, _len1, _ref1, _ref2;\n\n    currMapData = this.get('currMapData');\n    tileSize = this.get('tileSize');\n    numXTiles = this.get('numXTiles');\n    numYTiles = this.get('numYTiles');\n    canvas = this.get('canvas');\n    ctx = this.get('ctx');\n    canvas.width = numXTiles * tileSize.x;\n    canvas.height = numYTiles * tileSize.y;\n    console.log('Finish loading atlasses');\n    _ref1 = currMapData.layers;\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      layer = _ref1[_i];\n      if (layer.type !== 'tilelayer') {\n        continue;\n      }\n      if (layer.name === 'sound' || layer.name === 'physics') {\n        continue;\n      }\n      _ref2 = layer.data;\n      for (tileIDX = _j = 0, _len1 = _ref2.length; _j < _len1; tileIDX = ++_j) {\n        tID = _ref2[tileIDX];\n        if (tID === 0) {\n          continue;\n        }\n        tPKT = this.getTilePacket(tID);\n        coords = {\n          x: (tileIDX % numXTiles) * tileSize.x,\n          y: Math.floor(tileIDX / numXTiles) * tileSize.y\n        };\n        ctx.drawImage(tPKT.img, tPKT.px, tPKT.py, tileSize.x, tileSize.y, coords.x, coords.y, tileSize.x, tileSize.y);\n      }\n    }\n    return this.callWhenRendered();\n  };\n\n  return TILEDMap;\n\n})(Model);\n\n//@ sourceURL=models/TILEDMap.coffee"));
window.require.register("models/base/collection", Function('exports, require, module', "var Chaplin, Collection, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nModel = require('models/base/model');\n\nmodule.exports = Collection = (function(_super) {\n  __extends(Collection, _super);\n\n  function Collection() {\n    _ref = Collection.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Collection.prototype.model = Model;\n\n  return Collection;\n\n})(Chaplin.Collection);\n\n//@ sourceURL=models/base/collection.coffee"));
window.require.register("models/base/model", Function('exports, require, module', "var Chaplin, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Model = (function(_super) {\n  __extends(Model, _super);\n\n  function Model() {\n    _ref = Model.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Model;\n\n})(Chaplin.Model);\n\n//@ sourceURL=models/base/model.coffee"));
window.require.register("models/home", Function('exports, require, module', "var Home, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmodule.exports = Home = (function(_super) {\n  __extends(Home, _super);\n\n  function Home() {\n    _ref = Home.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Home;\n\n})(Model);\n\n//@ sourceURL=models/home.coffee"));
window.require.register("routes", Function('exports, require, module', "module.exports = function(match) {\n  match('', 'home#index');\n  match('index.html', 'home#index');\n  match('u/6045251/shiny-wight/index.html', 'home#index');\n  return match('shiny-wight/index.html', 'home#index');\n};\n\n//@ sourceURL=routes.coffee"));
window.require.register("views/base/collection-view", Function('exports, require, module', "var Chaplin, CollectionView, View, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nView = require('views/base/view');\n\nmodule.exports = CollectionView = (function(_super) {\n  __extends(CollectionView, _super);\n\n  function CollectionView() {\n    _ref = CollectionView.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  CollectionView.prototype.getTemplateFunction = View.prototype.getTemplateFunction;\n\n  return CollectionView;\n\n})(Chaplin.CollectionView);\n\n//@ sourceURL=views/base/collection-view.coffee"));
window.require.register("views/base/view", Function('exports, require, module', "var Chaplin, View, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nrequire('lib/view-helper');\n\nmodule.exports = View = (function(_super) {\n  __extends(View, _super);\n\n  function View() {\n    _ref = View.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  View.prototype.getTemplateFunction = function() {\n    return this.template;\n  };\n\n  return View;\n\n})(Chaplin.View);\n\n//@ sourceURL=views/base/view.coffee"));
window.require.register("views/home-page-view", Function('exports, require, module', "var EntitySpawnManager, HomePageView, InputManager, Level, PhysicsManager, Player, SoundManager, Std, TILEDMap, View, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nView = require('views/base/view');\n\nTILEDMap = require('models/TILEDMap');\n\nPlayer = require('models/Player');\n\nInputManager = require('models/InputManager');\n\nSoundManager = require('models/SoundManager');\n\nPhysicsManager = require('models/PhysicsManager');\n\nmediator = require('mediator');\n\nStd = require('models/Std');\n\nEntitySpawnManager = require('models/EntitySpawnManager');\n\nLevel = require('models/Level');\n\nmodule.exports = HomePageView = (function(_super) {\n  __extends(HomePageView, _super);\n\n  function HomePageView() {\n    this.draw = __bind(this.draw, this);\n    this.handleInput = __bind(this.handleInput, this);\n    this.doTheWork = __bind(this.doTheWork, this);\n    this.render = __bind(this.render, this);\n    this.setup = __bind(this.setup, this);\n    this.loadLevel = __bind(this.loadLevel, this);    _ref = HomePageView.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  HomePageView.prototype.autoRender = true;\n\n  HomePageView.prototype.className = 'home-page';\n\n  HomePageView.prototype.container = '#page-container';\n\n  HomePageView.prototype.initialize = function(options) {\n    var level,\n      _this = this;\n\n    HomePageView.__super__.initialize.apply(this, arguments);\n    new Std();\n    if (debug) {\n      window.homepageview = this;\n    }\n    mediator.PlayWithSounds = true;\n    if (debug) {\n      mediator.PlayWithSounds = confirm(\"Load Sounds?\");\n    }\n    this.skipFrame = true;\n    this.physicsManager = new PhysicsManager();\n    if (mediator.PlayWithSounds) {\n      this.soundManager = new SoundManager();\n    }\n    this.inputManager = new InputManager();\n    this.entitySpawnManager = new EntitySpawnManager();\n    level = 'level1';\n    if (mediator.PlayWithSounds) {\n      this.subscribeEvent('soundsLoaded', function() {\n        return _this.soundManager.startAll();\n      });\n    }\n    return this.loadLevel(level);\n  };\n\n  HomePageView.prototype.loadLevel = function(level) {\n    var map,\n      _this = this;\n\n    mediator.nextLevel = level;\n    map = new TILEDMap({\n      'callWhenRendered': function() {\n        _this.setup(level);\n        if (mediator.PlayWithSounds) {\n          return _this.soundManager.load(level);\n        }\n      }\n    });\n    return mediator.levels[level] = new Level(level + '.json', function() {\n      mediator.levels[level].gMap = map;\n      return mediator.levels[level].gMap.load(level);\n    });\n  };\n\n  HomePageView.prototype.setup = function(level) {\n    if (mediator.PlayWithSounds) {\n      this.soundManager.stopAll();\n    }\n    mediator.activeLevel = level;\n    mediator.entities = [];\n    this.physicsManager.setup();\n    this.entitySpawnManager.initialSpawn();\n    return window.requestAnimationFrame(this.doTheWork);\n  };\n\n  HomePageView.prototype.render = function() {\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    return this.el.appendChild(this.canvas);\n  };\n\n  HomePageView.prototype.doTheWork = function() {\n    var _this = this;\n\n    return setTimeout(function() {\n      var ent, _i, _len, _ref1;\n\n      window.requestAnimationFrame(_this.doTheWork);\n      _this.handleInput();\n      _ref1 = mediator.entities;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        ent = _ref1[_i];\n        ent.update();\n      }\n      _this.physicsManager.update();\n      return _this.draw();\n    }, 1000 / 25);\n  };\n\n  HomePageView.prototype.handleInput = function() {\n    var actions, moveDir, placeholder, player;\n\n    actions = this.inputManager.get('actions');\n    moveDir = new this.physicsManager.Vec2(0, 0);\n    player = mediator.player;\n    if (actions['move-up']) {\n      moveDir.y -= 1;\n      player.spriteState.viewDirection = 0;\n    }\n    if (actions['move-down']) {\n      moveDir.y += 1;\n      player.spriteState.viewDirection = 2;\n    }\n    if (actions['move-left']) {\n      moveDir.x -= 1;\n      player.spriteState.viewDirection = 3;\n    }\n    if (actions['move-right']) {\n      moveDir.x += 1;\n      player.spriteState.viewDirection = 1;\n    }\n    if (actions['interact']) {\n      placeholder = true;\n      this.loadLevel('level2');\n    }\n    if (actions['cancel']) {\n      placeholder = true;\n    }\n    if (moveDir.LengthSquared()) {\n      moveDir.Normalize();\n      moveDir.Multiply(player.VELOCITY);\n      player.physBody.SetLinearVelocity(moveDir);\n      if (mediator.PlayWithSounds) {\n        player.onPositionChange(mediator.player.position);\n      }\n      return player.spriteState.moving = true;\n    } else {\n      player.physBody.SetLinearVelocity(new this.physicsManager.Vec2(0, 0));\n      return player.spriteState.moving = false;\n    }\n  };\n\n  HomePageView.prototype.draw = function() {\n    var dh, dw, dx, dy, entity, numXTiles, numYTiles, pixelSize, pos, radiusOfSight, sh, sw, sx, sy, tileSize, _i, _len, _ref1, _results;\n\n    this.canvas.width = window.innerWidth / 2;\n    this.canvas.height = window.innerHeight;\n    tileSize = mediator.levels[mediator.activeLevel].gMap.get('tileSize');\n    pixelSize = mediator.levels[mediator.activeLevel].gMap.get('pixelSize');\n    numXTiles = mediator.levels[mediator.activeLevel].gMap.get('numXTiles');\n    numYTiles = mediator.levels[mediator.activeLevel].gMap.get('numYTiles');\n    pos = mediator.player.position;\n    radiusOfSight = 6 * tileSize.x;\n    sx = pos.x - radiusOfSight;\n    sy = pos.y - radiusOfSight;\n    sw = dw = sh = dh = radiusOfSight * 2 + tileSize.x;\n    dx = 0;\n    dy = 0;\n    if (sx < 0) {\n      sx = 0;\n    }\n    if (sy < 0) {\n      sy = 0;\n    }\n    if (sx + sw > pixelSize.x) {\n      sx = pixelSize.x - sw;\n    }\n    if (sy + sh > pixelSize.y) {\n      sy = pixelSize.y - sh;\n    }\n    this.ctx.drawImage(mediator.levels[mediator.activeLevel].gMap.get('canvas'), sx, sy, sw, sh, dx, dy, dw, dh);\n    _ref1 = mediator.entities;\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      entity = _ref1[_i];\n      _results.push(entity.render(this.ctx, sx, sy));\n    }\n    return _results;\n  };\n\n  return HomePageView;\n\n})(View);\n\n//@ sourceURL=views/home-page-view.coffee"));
window.require.register("views/layout", Function('exports, require, module', "var Chaplin, Layout, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Layout = (function(_super) {\n  __extends(Layout, _super);\n\n  function Layout() {\n    _ref = Layout.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Layout;\n\n})(Chaplin.Layout);\n\n//@ sourceURL=views/layout.coffee"));
