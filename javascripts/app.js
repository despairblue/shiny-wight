(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    definition(module.exports, localRequire(name), module);
    var exports = cache[name] = module.exports;
    return exports;
  };

  var require = function(name) {
    var path = expand(name, '.');

    if (has(cache, path)) return cache[path];
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex];
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.brunch = true;
})();

window.require.register("application", Function('exports, require, module', "var Application, Chaplin, Layout, mapManager, mediator, routes, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nLayout = require('views/layout');\n\nmediator = require('mediator');\n\nmapManager = require('models/TILEDMap');\n\nroutes = require('routes');\n\nmodule.exports = Application = (function(_super) {\n  __extends(Application, _super);\n\n  function Application() {\n    _ref = Application.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Application.prototype.title = 'shiny wight';\n\n  Application.prototype.initialize = function() {\n    Application.__super__.initialize.apply(this, arguments);\n    this.initDispatcher({\n      controllerSuffix: '-controller'\n    });\n    this.initLayout();\n    this.initMediator();\n    this.initControllers();\n    this.initGameSpecificStuff();\n    this.initRouter(routes);\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  Application.prototype.initLayout = function() {\n    return this.layout = new Layout({\n      title: this.title\n    });\n  };\n\n  Application.prototype.initControllers = function() {};\n\n  Application.prototype.initMediator = function() {\n    var _this = this;\n\n    mediator.map = null;\n    mediator.soundManager = null;\n    mediator.mapManager = mapManager;\n    mediator.playWithSounds = false;\n    mediator.factory = {};\n    mediator.levels = {};\n    mediator.activeLevel = \"\";\n    mediator.std = null;\n    mediator.getActiveLevel = function() {\n      return mediator.levels[mediator.activeLevel];\n    };\n    return mediator.seal();\n  };\n\n  Application.prototype.initGameSpecificStuff = function() {\n    (function() {\n      var lastTime, vendors, x;\n\n      lastTime = 0;\n      vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\n      x = 0;\n      while (x < vendors.length && !window.requestAnimationFrame) {\n        window.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n        window.cancelAnimationFrame = window[vendors[x] + \"CancelAnimationFrame\"] || window[vendors[x] + \"CancelRequestAnimationFrame\"];\n        ++x;\n      }\n      if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime, id, timeToCall;\n\n          currTime = new Date().getTime();\n          timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          id = window.setTimeout(function() {\n            return callback(currTime + timeToCall);\n          }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n      if (!window.cancelAnimationFrame) {\n        return window.cancelAnimationFrame = function(id) {\n          return clearTimeout(id);\n        };\n      }\n    })();\n    window.debug = document.location.hash.match(/debug/) && (typeof console !== \"undefined\" && console !== null);\n    return Object.getPrototypeOf(document.createElement('canvas').getContext('2d')).drawImageTiled = function(img, sx, sy, sw, sh, dx, dy, dw, dh, tileSizeX, tileSizeY) {\n      return this.drawImage(img, sx * tileSizeX, sy * tileSizeY, sw * tileSizeX, sh * tileSizeY, dx * tileSizeX, dy * tileSizeY, dw * tileSizeX, dh * tileSizeY);\n    };\n  };\n\n  return Application;\n\n})(Chaplin.Application);\n\n//@ sourceURL=application.coffee"));
window.require.register("controllers/base/controller", Function('exports, require, module', "var Chaplin, Controller, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Controller = (function(_super) {\n  __extends(Controller, _super);\n\n  function Controller() {\n    _ref = Controller.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Controller;\n\n})(Chaplin.Controller);\n\n//@ sourceURL=controllers/base/controller.coffee"));
window.require.register("controllers/home-controller", Function('exports, require, module', "var Controller, HomeController, HomePageView, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nController = require('controllers/base/controller');\n\nHomePageView = require('views/home-page-view');\n\nmodule.exports = HomeController = (function(_super) {\n  __extends(HomeController, _super);\n\n  function HomeController() {\n    _ref = HomeController.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  HomeController.prototype.index = function() {\n    return this.view = new HomePageView({\n      gMap: this.gMap\n    });\n  };\n\n  return HomeController;\n\n})(Controller);\n\n//@ sourceURL=controllers/home-controller.coffee"));
window.require.register("initialize", Function('exports, require, module', "var Application;\n\nApplication = require('application');\n\n$(function() {\n  var app;\n\n  app = new Application();\n  return app.initialize();\n});\n\n//@ sourceURL=initialize.coffee"));
window.require.register("lib/support", Function('exports, require, module', "var Chaplin, support, utils;\n\nChaplin = require('chaplin');\n\nutils = require('lib/utils');\n\nsupport = utils.beget(Chaplin.support);\n\nmodule.exports = support;\n\n//@ sourceURL=lib/support.coffee"));
window.require.register("lib/utils", Function('exports, require, module', "var Chaplin, utils;\n\nChaplin = require('chaplin');\n\nutils = Chaplin.utils.beget(Chaplin.utils);\n\nmodule.exports = utils;\n\n//@ sourceURL=lib/utils.coffee"));
window.require.register("lib/view-helper", Function('exports, require, module', "var mediator,\n  __slice = [].slice;\n\nmediator = require('mediator');\n\nHandlebars.registerHelper('with', function(context, options) {\n  if (!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(context);\n  }\n});\n\nHandlebars.registerHelper('without', function(context, options) {\n  var inverse;\n\n  inverse = options.inverse;\n  options.inverse = options.fn;\n  options.fn = inverse;\n  return Handlebars.helpers[\"with\"].call(this, context, options);\n});\n\nHandlebars.registerHelper('url', function() {\n  var params, routeName, url;\n\n  routeName = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  url = null;\n  mediator.publish('!router:reverse', routeName, params, function(result) {\n    return url = result;\n  });\n  return \"/\" + url;\n});\n\n//@ sourceURL=lib/view-helper.coffee"));
window.require.register("mediator", Function('exports, require, module', "module.exports = require('chaplin').mediator;\n\n//@ sourceURL=mediator.coffee"));
window.require.register("models/DeadEntity", Function('exports, require, module', "var DeadEntity, VisibleEntity, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nVisibleEntity = require('models/VisibleEntity');\n\nmodule[\"extends\"] = DeadEntity = (function(_super) {\n  __extends(DeadEntity, _super);\n\n  function DeadEntity() {\n    _ref = DeadEntity.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return DeadEntity;\n\n})(VisibleEntity);\n\n//@ sourceURL=models/DeadEntity.coffee"));
window.require.register("models/Entity", Function('exports, require, module', "var Entity, Model, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\n/*\nBase class for all entities\n\n@example How to subclass Entity\n  module.exports = class VisibleEntity extends Entity\n    onAction: (object): ->\n      # do something\n*/\n\n\nmodule.exports = Entity = (function(_super) {\n  __extends(Entity, _super);\n\n  /*\n  @property [Object] The entity's position in pixels\n  @option position [Integer] x y coordinate\n  */\n\n\n  Entity.prototype.position = {\n    x: 0,\n    y: 0\n  };\n\n  /*\n  @property [Object] The entity's size\n  */\n\n\n  Entity.prototype.size = {\n    x: 0,\n    y: 0\n  };\n\n  /*\n  @property [Integer]\n  What sprite to draw\n  */\n\n\n  Entity.prototype.animationStep = 0;\n\n  /*\n  @property [Integer]\n  Entity' velocity\n  Standart velocity = 10\n  */\n\n\n  Entity.prototype.velocity = 400;\n\n  Entity.prototype.entityDef = {\n    ellipse: false,\n    type: \"dynamic\",\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    userData: {\n      ent: null\n    }\n  };\n\n  /*\n  @property [Integer]\n  In what direction the entity looks\n  \n      0:up\n      1:right\n      2:down\n      3:left\n  */\n\n\n  Entity.prototype.viewDirection = 0;\n\n  function Entity(x, y, width, height, owningLevel, settings) {\n    this.update = __bind(this.update, this);\n    this.onTouchEnd = __bind(this.onTouchEnd, this);\n    this.onTouchBegin = __bind(this.onTouchBegin, this);\n    this.onTouch = __bind(this.onTouch, this);\n    this.render = __bind(this.render, this);\n    this.load = __bind(this.load, this);\n    this.onPositionChange = __bind(this.onPositionChange, this);\n    this.onAction = __bind(this.onAction, this);\n    var content, prop;\n\n    Entity.__super__.constructor.apply(this, arguments);\n    for (prop in settings) {\n      content = settings[prop];\n      this[prop] = content;\n    }\n    this.level = owningLevel;\n    this.position = {\n      x: x,\n      y: y\n    };\n    this.size.x = width;\n    this.size = {\n      x: width,\n      y: height\n    };\n    this.entityDef = {\n      ellipse: false,\n      type: \"dynamic\",\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      userData: {\n        ent: null\n      }\n    };\n    this.entityDef.x = this.position.x;\n    this.entityDef.y = this.position.y;\n    this.entityDef.width = width;\n    this.entityDef.height = height;\n    this.entityDef.userData.ent = this;\n    if (settings.ellipse) {\n      this.entityDef.ellipse = true;\n    }\n    if (settings.physicsType) {\n      this.entityDef.type = settings.physicsType;\n    }\n    this.physBody = this.level.physicsManager.addBody(this.entityDef, this.level.b2World);\n    this.physBody.SetLinearVelocity(new this.level.physicsManager.Vec2(0, 0));\n  }\n\n  /*\n  @private\n  Initializes the new Entity.\n  Will try to get the map from the mediator.\n  @note Make sure to call `TILEDMap.load(path)` before instantiating any Entities.\n  */\n\n\n  Entity.prototype.initialize = function() {\n    return this.map = mediator.levels[mediator.activeLevel].gMap;\n  };\n\n  /*\n  Is called if the Player stands in front of this Entity and want's to interact with it.\n  @param [Object] player\n    The Player.\n  */\n\n\n  Entity.prototype.onAction = function(player) {};\n\n  /*\n  Is called when the Entity moved\n  @note removed publish event 'anyEntityhere:moved' for much(!) better performance\n  */\n\n\n  Entity.prototype.onPositionChange = function() {};\n\n  Entity.prototype.load = function() {};\n\n  Entity.prototype.render = function() {};\n\n  Entity.prototype.onTouch = function(body, point, impulse) {};\n\n  Entity.prototype.onTouchBegin = function(body, point) {};\n\n  Entity.prototype.onTouchEnd = function(body, point) {};\n\n  /*\n  Is called each tick/frame.\n  */\n\n\n  Entity.prototype.update = function() {};\n\n  return Entity;\n\n})(Model);\n\n//@ sourceURL=models/Entity.coffee"));
window.require.register("models/InputManager", Function('exports, require, module', "var InputManager, Model, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmodule.exports = InputManager = (function(_super) {\n  __extends(InputManager, _super);\n\n  function InputManager() {\n    this.bind = __bind(this.bind, this);\n    this.onKeyUpEvent = __bind(this.onKeyUpEvent, this);\n    this.onKeyDownEvent = __bind(this.onKeyDownEvent, this);\n    this.initialize = __bind(this.initialize, this);    _ref = InputManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  InputManager.prototype.defaults = {\n    bindings: {},\n    actions: {},\n    presses: {},\n    locks: {},\n    delayedKeyup: [],\n    keyCodes: {\n      'a': 65,\n      'w': 87,\n      'd': 68,\n      's': 83,\n      'enter': 13,\n      'escape': 27,\n      'space': 32\n    }\n  };\n\n  InputManager.prototype.initialize = function() {\n    var keyCodes;\n\n    keyCodes = this.get('keyCodes');\n    this.bind(keyCodes['w'], 'move-up');\n    this.bind(keyCodes['a'], 'move-left');\n    this.bind(keyCodes['s'], 'move-down');\n    this.bind(keyCodes['d'], 'move-right');\n    this.bind(keyCodes['enter'], 'interact');\n    this.bind(keyCodes['space'], 'interact');\n    this.bind(keyCodes['escape'], 'cancel');\n    window.addEventListener('keydown', this.onKeyDownEvent);\n    window.addEventListener('keyup', this.onKeyUpEvent);\n    return this.otherKeyPressed = false;\n  };\n\n  /*\n  Set the corresponding action in the actions array to true\n  \n      Pressing `w` will set `move-up` to true on an qwerty keyboard\n  @params [Event] event Event Object\n  */\n\n\n  InputManager.prototype.onKeyDownEvent = function(event) {\n    var action, actions, bindings, code;\n\n    code = event['keyCode'];\n    if (this.otherKeyPressed) {\n      this.onKeyUpEvent(this.otherKeyPressed);\n    }\n    bindings = this.get('bindings');\n    actions = this.get('actions');\n    action = bindings[code];\n    if (action) {\n      actions[action] = true;\n    }\n    this.set({\n      'actions': actions\n    });\n    return this.otherKeyPressed = event;\n  };\n\n  /*\n  Set the corresponding action in the actions array to false\n  \n      Releasing `w` will set `move-up` to false on an qwerty keyboard\n  @params [Event] event Event Object\n  */\n\n\n  InputManager.prototype.onKeyUpEvent = function(event) {\n    var action, actions, bindings, code;\n\n    bindings = this.get('bindings');\n    actions = this.get('actions');\n    code = event['keyCode'];\n    action = bindings[code];\n    if (action) {\n      actions[action] = false;\n    }\n    return this.set({\n      'actions': actions\n    });\n  };\n\n  /*\n  Bind a key code to an action.\n  @example How to bind `w` to the `move-up` action\n    @bind 87, 'move-up'\n  */\n\n\n  InputManager.prototype.bind = function(key, action) {\n    var bindings;\n\n    bindings = this.get('bindings');\n    return bindings[key] = action;\n  };\n\n  return InputManager;\n\n})(Model);\n\n//@ sourceURL=models/InputManager.coffee"));
window.require.register("models/Level", Function('exports, require, module', "var Level, Model, PhysicsManager, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nPhysicsManager = require('models/PhysicsManager');\n\nmediator = require('mediator');\n\nmodule.exports = Level = (function(_super) {\n  __extends(Level, _super);\n\n  Level.prototype.manifest = null;\n\n  Level.prototype._callback = null;\n\n  Level.prototype.soundList = {};\n\n  Level.prototype.backgroundSoundList = {};\n\n  Level.prototype.soundTheme = null;\n\n  Level.prototype.soundCount = 0;\n\n  Level.prototype.b2World = null;\n\n  Level.prototype.physicsLoopHZ = 1 / 25;\n\n  Level.prototype.entities = {};\n\n  Level.prototype.entityObjects = [];\n\n  Level.prototype.player = null;\n\n  Level.prototype.bodyCount = 0;\n\n  Level.prototype.mapCanvas = null;\n\n  Level.prototype.mapTiledObject = null;\n\n  Level.prototype.tileSets = null;\n\n  Level.prototype.bodiesLoaded = false;\n\n  Level.prototype.mapLoaded = false;\n\n  Level.prototype.loadCompleted = false;\n\n  Level.prototype.setupped = false;\n\n  function Level(manifestUri, _callback) {\n    var _this = this;\n\n    this._callback = _callback;\n    this.update = __bind(this.update, this);\n    this.createEntity = __bind(this.createEntity, this);\n    this.initialSpawn = __bind(this.initialSpawn, this);\n    this.checkIfDone = __bind(this.checkIfDone, this);\n    this.setup = __bind(this.setup, this);\n    this.entities = {};\n    this.entityObjects = [];\n    mediator.std.xhrGet(manifestUri, function(data) {\n      var file, _i, _len, _ref;\n\n      _this.manifest = JSON.parse(data.target.responseText);\n      _this.bodyCount = _this.manifest.entities.files.length;\n      _ref = _this.manifest.entities.files;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        mediator.std.xhrGet(_this.manifest.entities.prefix + '/' + file, function(data) {\n          var ent;\n\n          ent = JSON.parse(data.target.responseText);\n          _this.entities[ent.tiledName] = ent;\n          _this.bodyCount--;\n          if (_this.bodyCount <= 0) {\n            _this.bodiesLoaded = true;\n            return _this.checkIfDone();\n          }\n        });\n      }\n      return mediator.std.xhrGet(_this.manifest.map.prefix + '/' + _this.manifest.map.file, function(data) {\n        _this.mapTiledObject = JSON.parse(data.target.responseText);\n        mediator.mapManager.parse(_this.mapTiledObject, function(map, tileSets) {\n          _this.mapCanvas = map;\n          _this.tileSets = tileSets;\n          _this.mapTiledObject.processedTileSets = _this.tileSets;\n          _this.mapLoaded = true;\n          _this.physicsManager = new PhysicsManager(_this.mapTiledObject);\n          _this.physicsManager.addContactListener({\n            PostSolve: function(bodyA, bodyB, impulse) {\n              var dataA, dataB;\n\n              dataA = bodyA.GetUserData();\n              dataB = bodyB.GetUserData();\n              if (dataA != null) {\n                dataA.ent.onTouch(bodyB, null, impulse);\n              }\n              return dataB != null ? dataB.ent.onTouch(bodyA, null, impulse) : void 0;\n            },\n            BeginContact: function(bodyA, bodyB) {\n              var dataA, dataB;\n\n              dataA = bodyA.GetUserData();\n              dataB = bodyB.GetUserData();\n              if (dataA != null) {\n                dataA.ent.onTouchBegin(bodyB, null);\n              }\n              return dataB != null ? dataB.ent.onTouchBegin(bodyA, null) : void 0;\n            },\n            EndContact: function(bodyA, bodyB) {\n              var dataA, dataB;\n\n              dataA = bodyA.GetUserData();\n              dataB = bodyB.GetUserData();\n              if (dataA != null) {\n                dataA.ent.onTouchEnd(bodyB, null);\n              }\n              return dataB != null ? dataB.ent.onTouchEnd(bodyA, null) : void 0;\n            }\n          });\n          return _this.checkIfDone();\n        });\n        if (mediator.playWithSounds) {\n          _this.soundMap = mediator.soundManager.getSoundMap(_this.mapTiledObject);\n          return mediator.soundManager.loadSounds(_this.manifest.sounds, function(soundList, backgroundSoundList, themeSound) {\n            _this.soundList = soundList;\n            _this.backgroundSoundList = backgroundSoundList;\n            _this.themeSound = themeSound;\n            _this.soundsLoaded = true;\n            return _this.checkIfDone();\n          });\n        }\n      });\n    });\n  }\n\n  Level.prototype.setup = function() {\n    if (this.loadCompleted) {\n      if (!this.setupped) {\n        this.setupped = true;\n        return this.initialSpawn();\n      } else {\n        return console.error(\"Level already set up!\");\n      }\n    } else {\n      return console.error(\"Don't call Level.setup() unless the manifest finished loading!\");\n    }\n  };\n\n  Level.prototype.checkIfDone = function() {\n    if (this.bodiesLoaded && this.mapLoaded && (this.soundsLoaded || !mediator.playWithSounds)) {\n      if (debug) {\n        console.log(\"level load completed\");\n      }\n      this.loadCompleted = true;\n      if (this._callback) {\n        return this._callback();\n      }\n    }\n  };\n\n  Level.prototype.initialSpawn = function(level) {\n    var layer, map, obj, object, _i, _len, _ref, _results;\n\n    if (!level) {\n      level = mediator.getActiveLevel();\n    }\n    map = level.mapTiledObject;\n    _ref = map.layers;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      layer = _ref[_i];\n      if (layer.type === 'tilelayer') {\n        continue;\n      }\n      if (layer.name !== 'spawnpoints') {\n        continue;\n      }\n      _results.push((function() {\n        var _j, _len1, _ref1, _results1;\n\n        _ref1 = layer.objects;\n        _results1 = [];\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          object = _ref1[_j];\n          if (object.type === '') {\n            continue;\n          }\n          obj = this.createEntity(object);\n          this.entityObjects.push(obj);\n          if (object.type === \"Player\") {\n            _results1.push(this.player = obj);\n          } else {\n            _results1.push(void 0);\n          }\n        }\n        return _results1;\n      }).call(this));\n    }\n    return _results;\n  };\n\n  Level.prototype.createEntity = function(object) {\n    var Ent, conf, content, height, obj, prop, width, x, y, _ref;\n\n    Ent = mediator.factory[object.type];\n    if (Object.keys(object.properties).length !== 0) {\n      conf = {};\n      _ref = object.properties;\n      for (prop in _ref) {\n        content = _ref[prop];\n        conf[prop] = content;\n      }\n    } else {\n      conf = this.entities[object.name];\n    }\n    if (!conf) {\n      console.error(\"No configuration file found for \" + object.name);\n      return \"No configuration found!\";\n    }\n    if (object.ellipse) {\n      conf.ellipse = true;\n    }\n    x = Math.floor(object.x);\n    y = Math.floor(object.y);\n    width = Math.floor(object.width);\n    height = Math.floor(object.height);\n    obj = new Ent(x, y, width, height, this, conf);\n    obj.load();\n    return obj;\n  };\n\n  Level.prototype.update = function() {\n    return this.physicsManager.update();\n  };\n\n  return Level;\n\n})(Model);\n\n//@ sourceURL=models/Level.coffee"));
window.require.register("models/MapChanger", Function('exports, require, module', "var Entity, MapChanger, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nEntity = require('models/Entity');\n\nmediator = require('mediator');\n\nmodule.exports = MapChanger = (function(_super) {\n  __extends(MapChanger, _super);\n\n  mediator.factory['MapChanger'] = MapChanger;\n\n  MapChanger.prototype.levelToChangeTo = \"\";\n\n  function MapChanger(x, y, width, height, owningLevel, settings) {\n    this.onTouchBegin = __bind(this.onTouchBegin, this);\n    var levelToChangeTo;\n\n    settings.physicsType = 'static';\n    MapChanger.__super__.constructor.call(this, x, y, width, height, owningLevel, settings);\n    levelToChangeTo = \"pisse\";\n  }\n\n  MapChanger.prototype.onTouchBegin = function(body, point, impulse) {\n    if (mediator.playWithSounds) {\n      mediator.soundManager.stopAll();\n    }\n    mediator.activeLevel = this.levelToChangeTo;\n    return this.publishEvent('changeLvl');\n  };\n\n  return MapChanger;\n\n})(Entity);\n\n//@ sourceURL=models/MapChanger.coffee"));
window.require.register("models/PhysicsManager", Function('exports, require, module', "var Body, BodyDef, CircleShape, DebugDraw, Fixture, FixtureDef, MassData, Model, PhysicsManager, PolygonShape, RevoluteJointDef, Vec2, World, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nVec2 = Box2D.Common.Math.b2Vec2;\n\nBodyDef = Box2D.Dynamics.b2BodyDef;\n\nBody = Box2D.Dynamics.b2Body;\n\nFixtureDef = Box2D.Dynamics.b2FixtureDef;\n\nFixture = Box2D.Dynamics.b2Fixture;\n\nWorld = Box2D.Dynamics.b2World;\n\nMassData = Box2D.Collision.Shapes.b2MassData;\n\nPolygonShape = Box2D.Collision.Shapes.b2PolygonShape;\n\nCircleShape = Box2D.Collision.Shapes.b2CircleShape;\n\nDebugDraw = Box2D.Dynamics.b2DebugDraw;\n\nRevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;\n\n/*\nContains a map with all physics bodies.\nCan be used by Entities to decide whether they can move to a specific tile.\n@note The PhysicsManager expects only only one physics layer to be present\n*/\n\n\nmodule.exports = PhysicsManager = (function() {\n  PhysicsManager.prototype.world = null;\n\n  PhysicsManager.prototype.physicsLoopHZ = 1 / 25;\n\n  PhysicsManager.prototype.Vec2 = Box2D.Common.Math.b2Vec2;\n\n  PhysicsManager.prototype.BodyDef = Box2D.Dynamics.b2BodyDef;\n\n  PhysicsManager.prototype.Body = Box2D.Dynamics.b2Body;\n\n  PhysicsManager.prototype.FixtureDef = Box2D.Dynamics.b2FixtureDef;\n\n  PhysicsManager.prototype.Fixture = Box2D.Dynamics.b2Fixture;\n\n  PhysicsManager.prototype.World = Box2D.Dynamics.b2World;\n\n  PhysicsManager.prototype.MassData = Box2D.Collision.Shapes.b2MassData;\n\n  PhysicsManager.prototype.PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;\n\n  PhysicsManager.prototype.CircleShape = Box2D.Collision.Shapes.b2CircleShape;\n\n  PhysicsManager.prototype.DebugDraw = Box2D.Dynamics.b2DebugDraw;\n\n  PhysicsManager.prototype.RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;\n\n  /*\n  @private\n  Initializes an instance\n  */\n\n\n  function PhysicsManager(map) {\n    var dCanvas, dCtx, debugDraw;\n\n    this.map = map;\n    this.removeBody = __bind(this.removeBody, this);\n    this.addBody = __bind(this.addBody, this);\n    this.registerBody = __bind(this.registerBody, this);\n    this.addContactListener = __bind(this.addContactListener, this);\n    this.update = __bind(this.update, this);\n    this.createLevelBorder = __bind(this.createLevelBorder, this);\n    this.createStaticBodyWithPolygon = __bind(this.createStaticBodyWithPolygon, this);\n    this.createStaticBodyWithBox = __bind(this.createStaticBodyWithBox, this);\n    this.addBackgroundRigidBodies = __bind(this.addBackgroundRigidBodies, this);\n    this.world = new World(new Vec2(0, 10), false);\n    debugDraw = new Box2D.Dynamics.b2DebugDraw();\n    dCanvas = document.getElementById('debug-canvas');\n    dCtx = dCanvas.getContext('2d');\n    this.createLevelBorder(this.map);\n    dCanvas.width = window.innerWidth / 2 - 100;\n    dCanvas.height = window.innerHeight;\n    debugDraw.SetSprite(dCtx);\n    debugDraw.SetDrawScale(0.5);\n    debugDraw.SetFillAlpha(0.3);\n    debugDraw.SetLineThickness(1);\n    debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit);\n    this.world.SetDebugDraw(debugDraw);\n    this.addBackgroundRigidBodies(this.map);\n  }\n\n  PhysicsManager.prototype.addBackgroundRigidBodies = function() {\n    var layer, object, physicsTile, pkt, tileID, tileIndex, tileSize, vec2, vec2Array, x, y, _i, _len, _ref, _results;\n\n    _ref = this.map.layers;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      layer = _ref[_i];\n      if (layer.name !== 'physics') {\n        continue;\n      }\n      if (layer.type === 'objectgroup') {\n        _results.push((function() {\n          var _j, _len1, _ref1, _results1;\n\n          _ref1 = layer.objects;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            object = _ref1[_j];\n            if (object.polygon) {\n              vec2Array = (function() {\n                var _k, _len2, _ref2, _results2;\n\n                _ref2 = object.polygon;\n                _results2 = [];\n                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n                  vec2 = _ref2[_k];\n                  _results2.push(new Vec2(vec2.x, vec2.y));\n                }\n                return _results2;\n              })();\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, object.x, object.y));\n            } else {\n              _results1.push(this.createStaticBodyWithBox(object.x, object.y, object.width, object.height));\n            }\n          }\n          return _results1;\n        }).call(this));\n      } else if (layer.type === 'tilelayer') {\n        _results.push((function() {\n          var _j, _len1, _ref1, _results1;\n\n          _ref1 = layer.data;\n          _results1 = [];\n          for (tileIndex = _j = 0, _len1 = _ref1.length; _j < _len1; tileIndex = ++_j) {\n            tileID = _ref1[tileIndex];\n            if (tileID === 0) {\n              continue;\n            }\n            x = (tileIndex % this.map.width) * this.map.tilewidth;\n            y = Math.floor(tileIndex / this.map.width) * this.map.tileheight;\n            pkt = mediator.mapManager.getTilePacket(tileID, this.map.processedTileSets);\n            physicsTile = pkt.px / this.map.tilewidth;\n            tileSize = this.map.tilewidth;\n            if (physicsTile === 0) {\n              _results1.push(this.createStaticBodyWithBox(x, y, tileSize, tileSize));\n            } else if (physicsTile === 1) {\n              vec2Array = [new Vec2(0, tileSize), new Vec2(tileSize, 0), new Vec2(tileSize, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 2) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, tileSize), new Vec2(0, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 3) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, 0), new Vec2(tileSize, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else if (physicsTile === 4) {\n              vec2Array = [new Vec2(0, 0), new Vec2(tileSize, 0), new Vec2(0, tileSize)];\n              _results1.push(this.createStaticBodyWithPolygon(vec2Array, x, y));\n            } else {\n              _results1.push(void 0);\n            }\n          }\n          return _results1;\n        }).call(this));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  PhysicsManager.prototype.createStaticBodyWithBox = function(x, y, w, h) {\n    var bgRigidBody, body, fixtureDefinition;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(w / 2, h / 2);\n    bgRigidBody = new BodyDef();\n    bgRigidBody.type = Body.b2_staticBody;\n    bgRigidBody.position.x = x + w / 2;\n    bgRigidBody.position.y = y + h / 2;\n    body = this.registerBody(bgRigidBody);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  PhysicsManager.prototype.createStaticBodyWithPolygon = function(vec2Array, x, y) {\n    var bgRigidBody, body, fixtureDefinition;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsArray(vec2Array, vec2Array.length);\n    bgRigidBody = new BodyDef();\n    bgRigidBody.type = Body.b2_staticBody;\n    bgRigidBody.position.x = x;\n    bgRigidBody.position.y = y;\n    body = this.registerBody(bgRigidBody);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  /*\n  @todo movo to TiledMap\n  */\n\n\n  PhysicsManager.prototype.createLevelBorder = function() {\n    var body, fixtureDefinition, mapBorder;\n\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(0, this.map.tileheight * this.map.height);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder, this.world);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(0, this.map.tileheight * this.map.height);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = this.map.tilewidth * this.map.width;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder, this.world);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(this.map.tilewidth * this.map.width, 0);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = 0;\n    body = this.registerBody(mapBorder, this.world);\n    body.CreateFixture(fixtureDefinition);\n    fixtureDefinition = new FixtureDef();\n    fixtureDefinition.shape = new PolygonShape();\n    fixtureDefinition.shape.SetAsBox(this.map.tilewidth * this.map.width, 0);\n    mapBorder = new BodyDef();\n    mapBorder.type = Body.b2_staticBody;\n    mapBorder.position.x = 0;\n    mapBorder.position.y = this.map.tileheight * this.map.height;\n    body = this.registerBody(mapBorder, this.world);\n    return body.CreateFixture(fixtureDefinition);\n  };\n\n  PhysicsManager.prototype.update = function() {\n    var start;\n\n    start = Date.now();\n    this.world.Step(this.physicsLoopHZ, 10, 10);\n    if (debug) {\n      this.world.DrawDebugData();\n    }\n    return Date.now() - start;\n  };\n\n  PhysicsManager.prototype.addContactListener = function(callbacks) {\n    var listener;\n\n    listener = new Box2D.Dynamics.b2ContactListener();\n    if (callbacks.BeginContact) {\n      listener.BeginContact = function(contact) {\n        return callbacks.BeginContact(contact.GetFixtureA().GetBody(), contact.GetFixtureB().GetBody());\n      };\n    }\n    if (callbacks.EndContact) {\n      listener.EndContact = function(contact) {\n        return callbacks.EndContact(contact.GetFixtureA().GetBody(), contact.GetFixtureB().GetBody());\n      };\n    }\n    if (callbacks.PostSolve) {\n      listener.PostSolve = function(contact, impulse) {\n        return callbacks.PostSolve(contact.GetFixtureA().GetBody(), contact.GetFixtureB().GetBody(), impulse.normalImpulses[0]);\n      };\n    }\n    return this.world.SetContactListener(listener);\n  };\n\n  PhysicsManager.prototype.registerBody = function(bodyDef) {\n    var body;\n\n    return body = this.world.CreateBody(bodyDef);\n  };\n\n  PhysicsManager.prototype.addBody = function(entityDef) {\n    var body, bodyDef, fixtureDefinition, halfHeight, halfWidth;\n\n    bodyDef = new BodyDef();\n    halfWidth = Math.floor(entityDef.width / 2);\n    halfHeight = Math.floor(entityDef.height / 2);\n    if (entityDef.type === 'static') {\n      bodyDef.type = Body.b2_staticBody;\n    } else {\n      bodyDef.type = Body.b2_dynamicBody;\n    }\n    bodyDef.position.x = entityDef.x + halfWidth;\n    bodyDef.position.y = entityDef.y + halfHeight;\n    if (entityDef.userData) {\n      bodyDef.userData = entityDef.userData;\n    }\n    body = this.registerBody(bodyDef);\n    fixtureDefinition = new FixtureDef();\n    if (entityDef.ellipse) {\n      fixtureDefinition.shape = new CircleShape();\n      fixtureDefinition.shape.SetRadius(halfWidth);\n    } else {\n      fixtureDefinition.shape = new PolygonShape();\n      fixtureDefinition.shape.SetAsBox(halfWidth, halfHeight);\n    }\n    body.CreateFixture(fixtureDefinition);\n    return body;\n  };\n\n  PhysicsManager.prototype.removeBody = function(obj) {\n    return this.world.DestroyBody(obj);\n  };\n\n  return PhysicsManager;\n\n})();\n\n//@ sourceURL=models/PhysicsManager.coffee"));
window.require.register("models/Player", Function('exports, require, module', "var Entity, Player, mediator,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nEntity = require('models/Entity');\n\nmediator = require('mediator');\n\n/*\nThe Player\n*/\n\n\nmodule.exports = Player = (function(_super) {\n  __extends(Player, _super);\n\n  mediator.factory['Player'] = Player;\n\n  Player.prototype.animationState = [0, 1, 2, 1];\n\n  function Player(x, y, width, height, owningLevel, settings) {\n    this.render = __bind(this.render, this);\n    this.getSpritePacket = __bind(this.getSpritePacket, this);\n    this.update = __bind(this.update, this);\n    this.onTouchBegin = __bind(this.onTouchBegin, this);\n    this.onTouch = __bind(this.onTouch, this);\n    this.load = __bind(this.load, this);\n    this.kill = __bind(this.kill, this);    settings.ellipse = true;\n    Player.__super__.constructor.call(this, x, y, width / 2, height / 2, owningLevel, settings);\n    this.size.x = width;\n    this.size.y = height;\n    this.spriteState.creationTime = Date.now();\n  }\n\n  Player.prototype.kill = function() {\n    mediator.physicsManager.removeBody(this.physBody);\n    this.physBody = null;\n    return this.killed = true;\n  };\n\n  Player.prototype.load = function() {\n    var img, tileSet;\n\n    tileSet = this.tileSet;\n    img = new Image();\n    img.src = tileSet.image;\n    return this.set({\n      'atlas': img\n    });\n  };\n\n  Player.prototype.onTouch = function(otherBody, point, impulse) {\n    var physOwner;\n\n    if (this.physBody == null) {\n      return false;\n    }\n    if (otherBody.GetUserData() == null) {\n      return false;\n    }\n    physOwner = otherBody.GetUserData().ent;\n    if (physOwner != null ? physOwner.killed : void 0) {\n      return false;\n    } else {\n\n    }\n  };\n\n  Player.prototype.onTouchBegin = function(otherBody, point) {\n    if (debug) {\n      return console.log(\"Player hit his head!\");\n    }\n  };\n\n  Player.prototype.update = function() {\n    if (this.physBody.GetPosition().x != null) {\n      this.position.x = this.physBody.GetPosition().x;\n    }\n    if (this.physBody.GetPosition().y != null) {\n      return this.position.y = this.physBody.GetPosition().y;\n    }\n  };\n\n  Player.prototype.getSpritePacket = function() {\n    var pkt, x, y;\n\n    x = Math.floor((Date.now() - this.spriteState.creationTime) / this.spriteState.animationRate) % this.tileSet.tilesX;\n    y = this.spriteState.viewDirection;\n    if (!this.spriteState.moving) {\n      x = this.spriteState.normal;\n    }\n    return pkt = {\n      x: x * this.tileSet.tilewidth,\n      y: y * this.tileSet.tileheight\n    };\n  };\n\n  Player.prototype.render = function(ctx, cx, cy) {\n    var animationState, dh, dw, dx, dy, img, sh, spritePkt, sw, sx, sy, tileSet;\n\n    tileSet = this.tileSet;\n    animationState = this.animationState;\n    img = this.get('atlas');\n    spritePkt = this.getSpritePacket();\n    sx = spritePkt.x;\n    sy = spritePkt.y;\n    sw = this.tileSet.tilewidth;\n    sh = this.tileSet.tileheight;\n    dx = this.position.x - cx;\n    dy = this.position.y - cy;\n    dw = this.size.x;\n    dh = this.size.y;\n    dx = dx - this.tileSet.offset.x;\n    dy = dy - this.tileSet.offset.y;\n    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\n  };\n\n  Player.prototype.onPositionChange = function() {\n    return mediator.soundManager.updateBackgroundSounds(this.position);\n  };\n\n  return Player;\n\n})(Entity);\n\n//@ sourceURL=models/Player.coffee"));
window.require.register("models/SoundManager", Function('exports, require, module', "var Model, SoundManager, SoundObj, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nSoundObj = require('models/SoundObj');\n\nmediator = require('mediator');\n\nmodule.exports = SoundManager = (function(_super) {\n  __extends(SoundManager, _super);\n\n  function SoundManager() {\n    this.startAll = __bind(this.startAll, this);\n    this.fade = __bind(this.fade, this);\n    this.updateBackgroundSounds = __bind(this.updateBackgroundSounds, this);\n    this.startBackgroundSounds = __bind(this.startBackgroundSounds, this);\n    this.stopAll = __bind(this.stopAll, this);\n    this.stop = __bind(this.stop, this);\n    this.playSound = __bind(this.playSound, this);\n    this.bufferSounds = __bind(this.bufferSounds, this);\n    this.loadSounds = __bind(this.loadSounds, this);\n    this.getSoundMap = __bind(this.getSoundMap, this);\n    this.initialize = __bind(this.initialize, this);    _ref = SoundManager.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  SoundManager.prototype.audioContext = null;\n\n  SoundManager.prototype.PATH = 'sounds/';\n\n  SoundManager.prototype.FADE_TIME_INTERVAL = 1;\n\n  /*\n  Initialize Soundmanager.\n  Create a new audio context and bind soundManager to mediator\n  */\n\n\n  SoundManager.prototype.initialize = function() {\n    SoundManager.__super__.initialize.apply(this, arguments);\n    mediator.soundManager = this;\n    this.audioContext = new webkitAudioContext();\n    return this.subscribeEvent('stopCurrentSounds', this.stopAll);\n  };\n\n  /*\n  @param [String]\n  @param [map]\n  Initializes soundMap for backgroundSounds\n  */\n\n\n  SoundManager.prototype.getSoundMap = function(map) {\n    var layer, soundMap, tileID, tileIndex, x, y, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3;\n\n    soundMap = [];\n    for (x = _i = 0, _ref1 = map.width - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = 0 <= _ref1 ? ++_i : --_i) {\n      soundMap[x] = (function() {\n        var _j, _ref2, _results;\n\n        _results = [];\n        for (y = _j = 0, _ref2 = map.height - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; y = 0 <= _ref2 ? ++_j : --_j) {\n          _results.push([]);\n        }\n        return _results;\n      })();\n    }\n    _ref2 = map.layers;\n    for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n      layer = _ref2[_j];\n      if (layer.name !== 'sound') {\n        continue;\n      }\n      _ref3 = layer.data;\n      for (tileIndex = _k = 0, _len1 = _ref3.length; _k < _len1; tileIndex = ++_k) {\n        tileID = _ref3[tileIndex];\n        if (tileID === 0) {\n          continue;\n        }\n        x = tileIndex % map.width;\n        y = Math.floor(tileIndex / map.width);\n        soundMap[x][y].push(layer.properties);\n      }\n    }\n    return soundMap;\n  };\n\n  SoundManager.prototype.loadSounds = function(mapSounds, callback) {\n    var sound, _i, _j, _len, _len1, _ref1, _ref2;\n\n    this.soundCount = mapSounds.sounds.length + 1 + mapSounds.backgroundSounds.length;\n    this.soundList = {};\n    this.backgroundSounds = {};\n    this.themeSound = {};\n    _ref1 = mapSounds.sounds;\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      sound = _ref1[_i];\n      this.soundList[sound] = new SoundObj;\n      mediator.std.xhrGet(mapSounds.prefix + sound, this.bufferSounds, 'arraybuffer', sound, this.soundList, callback);\n    }\n    _ref2 = mapSounds.backgroundSounds;\n    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n      sound = _ref2[_j];\n      this.backgroundSounds[sound] = new SoundObj;\n      mediator.std.xhrGet(mapSounds.prefix + sound, this.bufferSounds, 'arraybuffer', sound, this.backgroundSounds, callback);\n    }\n    this.themeSound[mapSounds.theme] = new SoundObj;\n    return mediator.std.xhrGet(mapSounds.prefix + mapSounds.theme, this.bufferSounds, 'arraybuffer', mapSounds.theme, this.themeSound, callback);\n  };\n\n  /*\n  @param [xhrGethttp-request]\n  Buffer the sound we just got from xhrGet request and put it into the corresponding SourceNode in the audio context\n  @note later trigger the observer event for 'all sounds loaded'\n  */\n\n\n  SoundManager.prototype.bufferSounds = function(event) {\n    var buffer, callback, list, request, sound;\n\n    request = event.target;\n    sound = request.additionalAttributes[0];\n    list = request.additionalAttributes[1];\n    callback = request.additionalAttributes[2];\n    buffer = this.audioContext.createBuffer(request.response, false);\n    list[sound].buffer = buffer;\n    if (debug) {\n      console.log(sound + ' loaded');\n    }\n    this.soundCount--;\n    if (this.soundCount <= 0) {\n      return callback(this.soundList, this.backgroundSounds, this.themeSound);\n    }\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  @param [Double]\n  @param [Bool]\n  Play sound of list with volume and loop\n  */\n\n\n  SoundManager.prototype.playSound = function(sound, list, volume, loops) {\n    var sourceNode;\n\n    sourceNode = this.audioContext.createBufferSource();\n    sourceNode.buffer = list[sound].buffer;\n    sourceNode.loop = loops;\n    sourceNode.gain.value = volume;\n    sourceNode.connect(this.audioContext.destination);\n    list[sound].sourceNode = sourceNode;\n    return sourceNode.start(0);\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  Stop sound in list\n  */\n\n\n  SoundManager.prototype.stop = function(sound, list) {\n    this.fade(sound, list, 0);\n    list[sound].sourceNode.stop(this.audioContext.currentTime + this.FADE_TIME_INTERVAL);\n    list[sound].isPlaying = false;\n    if (debug) {\n      return console.log(sound + '.mp3 stopped');\n    }\n  };\n\n  /*\n  Stop all sounds in active level\n  */\n\n\n  SoundManager.prototype.stopAll = function() {\n    var e, name, sound, _ref1, _ref2, _ref3, _results;\n\n    try {\n      _ref1 = mediator.getActiveLevel().soundList;\n      for (name in _ref1) {\n        sound = _ref1[name];\n        this.stop(name, mediator.getActiveLevel().soundList);\n      }\n      _ref2 = mediator.getActiveLevel().backgroundSoundList;\n      for (name in _ref2) {\n        sound = _ref2[name];\n        this.stop(name, mediator.getActiveLevel().backgroundSoundList);\n      }\n      _ref3 = mediator.getActiveLevel().themeSound;\n      _results = [];\n      for (name in _ref3) {\n        sound = _ref3[name];\n        _results.push(this.stop(name, mediator.getActiveLevel().themeSound));\n      }\n      return _results;\n    } catch (_error) {\n      e = _error;\n      if (debug) {\n        return console.log(e.toString());\n      }\n    }\n  };\n\n  /*\n  Start all background sounds in backgroundSound list of active level with gain = 0, i.e. muted\n  */\n\n\n  SoundManager.prototype.startBackgroundSounds = function() {\n    var name, sound, _ref1, _results;\n\n    _ref1 = mediator.getActiveLevel().backgroundSoundList;\n    _results = [];\n    for (name in _ref1) {\n      sound = _ref1[name];\n      this.playSound(name, mediator.getActiveLevel().backgroundSoundList, 0, true);\n      _results.push(sound.isPlaying = true);\n    }\n    return _results;\n  };\n\n  /*\n  @param [Object]\n  Look for backgroundSounds to play on the player position on the soundMap and update their gain\n  @todo maybe look for an optimization here\n  */\n\n\n  SoundManager.prototype.updateBackgroundSounds = function(PlayerPosition) {\n    var name, sound, _i, _len, _ref1, _ref2, _results;\n\n    this.backgroundSoundsToPlay = [];\n    _ref1 = mediator.getActiveLevel().soundMap[Math.floor(PlayerPosition.x / 32)][Math.floor(PlayerPosition.y / 32)];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      sound = _ref1[_i];\n      this.fade(sound.type + '.mp3', mediator.getActiveLevel().backgroundSoundList, sound.intensity / 100);\n      this.backgroundSoundsToPlay.push(sound.type + '.mp3');\n    }\n    _ref2 = mediator.getActiveLevel().backgroundSoundList;\n    _results = [];\n    for (name in _ref2) {\n      sound = _ref2[name];\n      if (this.backgroundSoundsToPlay.indexOf(name) === -1) {\n        _results.push(this.fade(name, mediator.getActiveLevel().backgroundSoundList, 0));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  /*\n  @param [String]\n  @param [Object]\n  @param [Double]\n  Fade sound in list to gain\n  */\n\n\n  SoundManager.prototype.fade = function(sound, list, volume) {\n    return list[sound].sourceNode.gain.setTargetAtTime(volume, this.audioContext.currentTime, this.FADE_TIME_INTERVAL);\n  };\n\n  SoundManager.prototype.startAll = function() {\n    this.playSound(mediator.activeLevel + 'theme.mp3', mediator.getActiveLevel().themeSound, 1, true);\n    this.startBackgroundSounds();\n    return this.updateBackgroundSounds(mediator.player.position);\n  };\n\n  return SoundManager;\n\n})(Model);\n\n//@ sourceURL=models/SoundManager.coffee"));
window.require.register("models/SoundObj", Function('exports, require, module', "var Model, SoundObj, mediator, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nmodule.exports = SoundObj = (function(_super) {\n  __extends(SoundObj, _super);\n\n  function SoundObj() {\n    _ref = SoundObj.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  SoundObj.prototype.sourceNode = null;\n\n  SoundObj.prototype.gainNode = null;\n\n  SoundObj.prototype.buffer = null;\n\n  SoundObj.prototype.isPlaying = false;\n\n  return SoundObj;\n\n})(Model);\n\n//@ sourceURL=models/SoundObj.coffee"));
window.require.register("models/Std", Function('exports, require, module', "var Model, Std, mediator, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __slice = [].slice;\n\nModel = require('models/base/model');\n\nmediator = require('mediator');\n\nmodule.exports = Std = (function(_super) {\n  __extends(Std, _super);\n\n  function Std() {\n    _ref = Std.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Std.prototype.initialize = function() {\n    return mediator.std = this;\n  };\n\n  /*\n  Starts a XMLHttpRequest and calls the given callback when finished loading.\n  @param [String] reqUri URI to the file to be loaded\n  @param [Function] callback Callback function\n  */\n\n\n  Std.prototype.xhrGet = function() {\n    var callback, reqUri, rest, xhr;\n\n    reqUri = arguments[0], callback = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n    xhr = new XMLHttpRequest();\n    if (rest.length !== 0) {\n      xhr.responseType = rest[0];\n    }\n    xhr.additionalAttributes = rest.splice(1);\n    xhr.open('GET', reqUri, true);\n    xhr.onload = callback;\n    return xhr.send();\n  };\n\n  return Std;\n\n})(Model);\n\n//@ sourceURL=models/Std.coffee"));
window.require.register("models/TILEDMap", Function('exports, require, module', "/*\nLoads and renders a level.\n@note emits `map:rendered` event when map ist fully rendered\n*/\n\nvar TILEDMap;\n\nmodule.exports = TILEDMap = (function() {\n  function TILEDMap() {}\n\n  /*\n  @private\n  Parses TILED map editor json data\n  @param [Object] mapTiledObject the parsed TILED map editor map data\n  */\n\n\n  TILEDMap.parseMapJSON = function(mapTiledObject, callback) {\n    var imgLoadCount, tileset, tilesets;\n\n    console.log('Start loading atlasses');\n    imgLoadCount = mapTiledObject.tilesets.length;\n    return tilesets = (function() {\n      var _i, _len, _ref, _results,\n        _this = this;\n\n      _ref = mapTiledObject.tilesets;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        tileset = _ref[_i];\n        _results.push(this.createTileSet(tileset, function() {\n          imgLoadCount--;\n          if (imgLoadCount <= 0) {\n            return callback(tilesets);\n          } else {\n            if (debug) {\n              return console.log(\"\" + imgLoadCount + \" tile sets to go. Hang in there!\");\n            }\n          }\n        }));\n      }\n      return _results;\n    }).call(TILEDMap);\n  };\n\n  /*\n  @private\n  Loads an atlas referenced from the map file and returns it\n  @param [Object] tileset a tileset from the map json\n  @return [Object] most important data from that tileset\n  @example The returned Object:\n    ts =\n      firstgid: …    # look at https://github.com/bjorn/tiled/wiki/TMX-Map-Format\n      image: …       # the loaded atlas image\n      imageheight: … # the atlas's height in pixels\n      imagewidth: …  # the atlas's width in pixels\n      name: …        # the atlas's name\n      numXTiles: …   # number of tiles in x direction\n      numYTiles: …   # number of tiles in y direction\n  */\n\n\n  TILEDMap.createTileSet = function(tileset, callback) {\n    var img, ts;\n\n    img = new Image();\n    img.onload = function() {\n      return callback();\n    };\n    img.src = 'atlases/' + tileset.image.replace(/^.*[\\\\\\/]/, '');\n    return ts = {\n      firstgid: tileset.firstgid,\n      image: img,\n      imageheight: tileset.imageheight,\n      imagewidth: tileset.imagewidth,\n      tileheight: tileset.tileheight,\n      tilewidth: tileset.tilewidth,\n      name: tileset.name,\n      numXTiles: Math.floor(tileset.imagewidth / (tileset.tilewidth + tileset.spacing)),\n      numYTiles: Math.floor(tileset.imageheight / (tileset.tileheight + tileset.spacing)),\n      spacing: tileset.spacing\n    };\n  };\n\n  /*\n  @private\n  Takes a tile ID and returns the tile's atlas and position\n  @param [Integer] tileIndex a tile ID\n  @return [Object] the tile's atlas and position\n  @example the returned Object:\n    pkt =\n      img: … # the atlas where the tile is situated\n      px: …  # x value of the top left corner in pixels\n      py: …  # y value of the top left corner in pixels\n  */\n\n\n  TILEDMap.getTilePacket = function(tileIndex, tileSets) {\n    var lTileX, lTileY, localIdx, pkt, tile, _i;\n\n    pkt = {\n      img: null,\n      px: 0,\n      py: 0\n    };\n    tile = null;\n    for (_i = tileSets.length - 1; _i >= 0; _i += -1) {\n      tile = tileSets[_i];\n      if (tile.firstgid <= tileIndex) {\n        break;\n      }\n    }\n    pkt.img = tile.image;\n    localIdx = tileIndex - tile.firstgid;\n    lTileX = Math.floor(localIdx % tile.numXTiles);\n    lTileY = Math.floor(localIdx / tile.numXTiles);\n    pkt.py = lTileY * (tile.tileheight + tile.spacing) + tile.spacing;\n    pkt.px = lTileX * (tile.tilewidth + tile.spacing) + tile.spacing;\n    return pkt;\n  };\n\n  /*\n  Renders the map into it's own off screen canvas.\n  This means the whol background can be drawn with one single draw\n  call instead of hundreads.\n  */\n\n\n  TILEDMap.render = function(mapTiledObject, tilesets) {\n    var canvas, coords, ctx, layer, tID, tPKT, tileIDX, _i, _j, _len, _len1, _ref, _ref1;\n\n    canvas = document.createElement('canvas');\n    ctx = canvas.getContext('2d');\n    canvas.width = mapTiledObject.width * mapTiledObject.tilewidth;\n    canvas.height = mapTiledObject.height * mapTiledObject.tileheight;\n    console.log('Finish loading atlasses');\n    _ref = mapTiledObject.layers;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      layer = _ref[_i];\n      if (layer.type !== 'tilelayer') {\n        continue;\n      }\n      if (layer.name === 'sound' || layer.name === 'physics') {\n        continue;\n      }\n      _ref1 = layer.data;\n      for (tileIDX = _j = 0, _len1 = _ref1.length; _j < _len1; tileIDX = ++_j) {\n        tID = _ref1[tileIDX];\n        if (tID === 0) {\n          continue;\n        }\n        tPKT = TILEDMap.getTilePacket(tID, tilesets);\n        coords = {\n          x: (tileIDX % mapTiledObject.width) * mapTiledObject.tilewidth,\n          y: Math.floor(tileIDX / mapTiledObject.width) * mapTiledObject.tileheight\n        };\n        ctx.drawImage(tPKT.img, tPKT.px, tPKT.py, mapTiledObject.tilewidth, mapTiledObject.tileheight, coords.x, coords.y, mapTiledObject.tilewidth, mapTiledObject.tileheight);\n      }\n    }\n    return canvas;\n  };\n\n  TILEDMap.parse = function(mapTiledObject, callback) {\n    return TILEDMap.parseMapJSON(mapTiledObject, function(tilesets) {\n      return callback(TILEDMap.render(mapTiledObject, tilesets), tilesets);\n    });\n  };\n\n  return TILEDMap;\n\n}).call(this);\n\n//@ sourceURL=models/TILEDMap.coffee"));
window.require.register("models/base/collection", Function('exports, require, module', "var Chaplin, Collection, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nModel = require('models/base/model');\n\nmodule.exports = Collection = (function(_super) {\n  __extends(Collection, _super);\n\n  function Collection() {\n    _ref = Collection.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  Collection.prototype.model = Model;\n\n  return Collection;\n\n})(Chaplin.Collection);\n\n//@ sourceURL=models/base/collection.coffee"));
window.require.register("models/base/model", Function('exports, require, module', "var Chaplin, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Model = (function(_super) {\n  __extends(Model, _super);\n\n  function Model() {\n    _ref = Model.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Model;\n\n})(Chaplin.Model);\n\n//@ sourceURL=models/base/model.coffee"));
window.require.register("models/home", Function('exports, require, module', "var Home, Model, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nModel = require('models/base/model');\n\nmodule.exports = Home = (function(_super) {\n  __extends(Home, _super);\n\n  function Home() {\n    _ref = Home.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Home;\n\n})(Model);\n\n//@ sourceURL=models/home.coffee"));
window.require.register("routes", Function('exports, require, module', "module.exports = function(match) {\n  match('', 'home#index');\n  match('index.html', 'home#index');\n  match('u/6045251/shiny-wight/index.html', 'home#index');\n  return match('shiny-wight/index.html', 'home#index');\n};\n\n//@ sourceURL=routes.coffee"));
window.require.register("views/base/collection-view", Function('exports, require, module', "var Chaplin, CollectionView, View, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nView = require('views/base/view');\n\nmodule.exports = CollectionView = (function(_super) {\n  __extends(CollectionView, _super);\n\n  function CollectionView() {\n    _ref = CollectionView.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  CollectionView.prototype.getTemplateFunction = View.prototype.getTemplateFunction;\n\n  return CollectionView;\n\n})(Chaplin.CollectionView);\n\n//@ sourceURL=views/base/collection-view.coffee"));
window.require.register("views/base/view", Function('exports, require, module', "var Chaplin, View, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nrequire('lib/view-helper');\n\nmodule.exports = View = (function(_super) {\n  __extends(View, _super);\n\n  function View() {\n    _ref = View.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  View.prototype.getTemplateFunction = function() {\n    return this.template;\n  };\n\n  return View;\n\n})(Chaplin.View);\n\n//@ sourceURL=views/base/view.coffee"));
window.require.register("views/home-page-view", Function('exports, require, module', "var HomePageView, InputManager, Level, MapChanger, Player, SoundManager, Std, Vec2, View, mediator, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __slice = [].slice;\n\nView = require('views/base/view');\n\nInputManager = require('models/InputManager');\n\nSoundManager = require('models/SoundManager');\n\nmediator = require('mediator');\n\nStd = require('models/Std');\n\nLevel = require('models/Level');\n\nPlayer = require('models/Player');\n\nMapChanger = require('models/MapChanger');\n\nVec2 = Box2D.Common.Math.b2Vec2;\n\nmodule.exports = HomePageView = (function(_super) {\n  __extends(HomePageView, _super);\n\n  function HomePageView() {\n    this.draw = __bind(this.draw, this);\n    this.handleInput = __bind(this.handleInput, this);\n    this.doTheWork = __bind(this.doTheWork, this);\n    this.render = __bind(this.render, this);\n    this.setup = __bind(this.setup, this);\n    this.loadNextLevels = __bind(this.loadNextLevels, this);\n    this.loadLevel = __bind(this.loadLevel, this);    _ref = HomePageView.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  HomePageView.prototype.autoRender = true;\n\n  HomePageView.prototype.className = 'home-page';\n\n  HomePageView.prototype.container = '#page-container';\n\n  HomePageView.prototype.initialize = function(options) {\n    var level,\n      _this = this;\n\n    HomePageView.__super__.initialize.apply(this, arguments);\n    new Std();\n    if (debug) {\n      window.homepageview = this;\n    }\n    if (debug) {\n      window.mediator = mediator;\n    }\n    mediator.playWithSounds = true;\n    if (debug) {\n      mediator.playWithSounds = confirm(\"Load Sounds?\");\n    }\n    if (mediator.playWithSounds) {\n      this.soundManager = new SoundManager();\n    }\n    this.inputManager = new InputManager();\n    this.subscribeEvent('changeLvl', function() {\n      if (debug) {\n        console.log('change to ' + mediator.activeLevel);\n      }\n      return _this.setup(mediator.activeLevel);\n    });\n    level = 'level1';\n    return this.loadLevel(level, function() {\n      _this.setup(level);\n      return window.requestAnimationFrame(_this.doTheWork);\n    });\n  };\n\n  HomePageView.prototype.loadLevel = function() {\n    var level, rest,\n      _this = this;\n\n    level = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (mediator.levels[level] != null) {\n      return;\n    }\n    return mediator.levels[level] = new Level(level + '.json', function() {\n      if (rest[0]) {\n        return rest[0]();\n      }\n    });\n  };\n\n  HomePageView.prototype.loadNextLevels = function() {\n    var entity, _i, _len, _ref1, _results;\n\n    _ref1 = mediator.getActiveLevel().entityObjects;\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      entity = _ref1[_i];\n      if (entity.levelToChangeTo == null) {\n        continue;\n      }\n      _results.push(this.loadLevel(entity.levelToChangeTo));\n    }\n    return _results;\n  };\n\n  HomePageView.prototype.setup = function(level) {\n    var lvl;\n\n    lvl = mediator.levels[level];\n    mediator.activeLevel = level;\n    if (!lvl.setupped) {\n      lvl.setup();\n    }\n    if (mediator.playWithSounds) {\n      this.soundManager.startAll();\n    }\n    return this.loadNextLevels();\n  };\n\n  HomePageView.prototype.render = function() {\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    return this.el.appendChild(this.canvas);\n  };\n\n  HomePageView.prototype.doTheWork = function() {\n    var _this = this;\n\n    return setTimeout(function() {\n      var ent, lvl, _i, _len, _ref1;\n\n      lvl = mediator.getActiveLevel();\n      window.requestAnimationFrame(_this.doTheWork);\n      _this.handleInput();\n      _ref1 = lvl.entityObjects;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        ent = _ref1[_i];\n        ent.update();\n      }\n      lvl.update();\n      return _this.draw();\n    }, 1000 / 25);\n  };\n\n  HomePageView.prototype.handleInput = function() {\n    var actions, moveDir, placeholder, player;\n\n    actions = this.inputManager.get('actions');\n    moveDir = new Vec2(0, 0);\n    player = mediator.getActiveLevel().player;\n    if (actions['move-up']) {\n      moveDir.y -= 1;\n      player.spriteState.viewDirection = 0;\n    }\n    if (actions['move-down']) {\n      moveDir.y += 1;\n      player.spriteState.viewDirection = 2;\n    }\n    if (actions['move-left']) {\n      moveDir.x -= 1;\n      player.spriteState.viewDirection = 3;\n    }\n    if (actions['move-right']) {\n      moveDir.x += 1;\n      player.spriteState.viewDirection = 1;\n    }\n    if (actions['interact']) {\n      placeholder = true;\n      this.loadLevel('level2');\n    }\n    if (actions['cancel']) {\n      placeholder = true;\n    }\n    if (moveDir.LengthSquared()) {\n      moveDir.Normalize();\n      moveDir.Multiply(player.velocity);\n      player.physBody.SetLinearVelocity(moveDir);\n      if (mediator.playWithSounds) {\n        player.onPositionChange();\n      }\n      return player.spriteState.moving = true;\n    } else {\n      player.physBody.SetLinearVelocity(new Vec2(0, 0));\n      return player.spriteState.moving = false;\n    }\n  };\n\n  HomePageView.prototype.draw = function() {\n    var dh, dw, dx, dy, entity, lvl, numXTiles, numYTiles, pixelSize, pos, radiusOfSight, sh, sw, sx, sy, tileSize, _i, _len, _ref1, _results;\n\n    lvl = mediator.getActiveLevel();\n    this.canvas.width = window.innerWidth / 2;\n    this.canvas.height = window.innerHeight;\n    numXTiles = lvl.mapTiledObject.width;\n    numYTiles = lvl.mapTiledObject.height;\n    tileSize = {\n      x: lvl.mapTiledObject.tileheight,\n      y: lvl.mapTiledObject.tilewidth\n    };\n    pixelSize = {\n      x: numXTiles * tileSize.x,\n      y: numYTiles * tileSize.y\n    };\n    pos = lvl.player.position;\n    radiusOfSight = 6 * tileSize.x;\n    sx = pos.x - radiusOfSight;\n    sy = pos.y - radiusOfSight;\n    sw = dw = sh = dh = radiusOfSight * 2 + tileSize.x;\n    dx = 0;\n    dy = 0;\n    if (sx + sw > pixelSize.x) {\n      sx = pixelSize.x - sw;\n    }\n    if (sy + sh > pixelSize.y) {\n      sy = pixelSize.y - sh;\n    }\n    if (sx < 0) {\n      sx = 0;\n    }\n    if (sy < 0) {\n      sy = 0;\n    }\n    if (sw - sx > pixelSize.x) {\n      sw = dw = pixelSize.x;\n    }\n    if (sh - sy > pixelSize.y) {\n      sh = dh = pixelSize.y;\n    }\n    this.ctx.drawImage(lvl.mapCanvas, sx, sy, sw, sh, dx, dy, dw, dh);\n    _ref1 = lvl.entityObjects;\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      entity = _ref1[_i];\n      _results.push(entity.render(this.ctx, sx, sy));\n    }\n    return _results;\n  };\n\n  return HomePageView;\n\n})(View);\n\n//@ sourceURL=views/home-page-view.coffee"));
window.require.register("views/layout", Function('exports, require, module', "var Chaplin, Layout, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nChaplin = require('chaplin');\n\nmodule.exports = Layout = (function(_super) {\n  __extends(Layout, _super);\n\n  function Layout() {\n    _ref = Layout.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  return Layout;\n\n})(Chaplin.Layout);\n\n//@ sourceURL=views/layout.coffee"));
